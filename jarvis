print("--- Jarvis Final Edition (Service Account Auth) ---")

import json, subprocess, platform, requests, pyautogui, os, asyncio
from datetime import datetime
import edge_tts
import pygame
import google.generativeai as genai
from google.oauth2 import service_account # ì„œë¹„ìŠ¤ ê³„ì • ì¸ì¦ì„ ìœ„í•´ ì¶”ê°€

# --- 1. ì„œë¹„ìŠ¤ ê³„ì • ë° ì—”ì§„ ì„¤ì • ---
try:
    # 2ë‹¨ê³„ì—ì„œ í”„ë¡œì íŠ¸ í´ë”ì— ë„£ì€ ì„œë¹„ìŠ¤ ê³„ì • í‚¤ íŒŒì¼ì˜ ì´ë¦„ì„ ì§€ì •í•©ë‹ˆë‹¤.
    SERVICE_ACCOUNT_FILE = 'service_account.json'
    
    script_dir = os.path.dirname(os.path.abspath(__file__))
    key_path = os.path.join(script_dir, SERVICE_ACCOUNT_FILE)

    # ì„œë¹„ìŠ¤ ê³„ì • íŒŒì¼ë¡œë¶€í„° ì¸ì¦ ì •ë³´ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
    credentials = service_account.Credentials.from_service_account_file(key_path)
    # API í‚¤ ëŒ€ì‹  ìƒì„±ëœ ì¸ì¦ ì •ë³´ë¡œ Geminië¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
    genai.configure(credentials=credentials)
    
    gemini_model = genai.GenerativeModel('gemini-1.5-flash-latest')
    
    VOICE = "ko-KR-SunHiNeural"
    RATE = "+20%"
    pygame.mixer.init()

except Exception as e:
    print(f"ì—”ì§„ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}\nì„œë¹„ìŠ¤ ê³„ì • íŒŒì¼ì˜ ê²½ë¡œì™€ ì´ë¦„ì´ ì˜¬ë°”ë¥¸ì§€ í™•ì¸í•˜ì„¸ìš”.")
    exit()

# --- 2. ì„¤ì • íŒŒì¼ ë¡œë“œ ---
try:
    json_path = os.path.join(script_dir, 'commands.json')
    with open(json_path, encoding="utf-8") as f:
        full_config = json.load(f)
    COMMANDS = {k: v for k, v in full_config.items() if not k.startswith("##")}
except FileNotFoundError:
    speak(f"ì˜¤ë¥˜. '{json_path}' ì—ì„œ commands.jsonì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    exit()

# (ì´í•˜ 3ë‹¨ê³„, 4ë‹¨ê³„ ì½”ë“œëŠ” ì´ì „ê³¼ ëª¨ë‘ ë™ì¼í•©ë‹ˆë‹¤.)
# --- 3. í•µì‹¬ ê¸°ëŠ¥ í•¨ìˆ˜ ---
def speak(text):
    print(f"ğŸ”Š ìë¹„ìŠ¤: {text}")
    try: asyncio.run(_speak_async(text))
    except Exception as e: print(f"ìŒì„± ì¶œë ¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

async def _speak_async(text):
    output_file = "response.mp3"
    try:
        communicate = edge_tts.Communicate(text, VOICE, rate=RATE)
        await communicate.save(output_file)
        pygame.mixer.music.load(output_file)
        pygame.mixer.music.play()
        while pygame.mixer.music.get_busy(): pygame.time.Clock().tick(10)
        pygame.mixer.music.unload(); await asyncio.sleep(0.1); os.remove(output_file)
    except Exception as e: print(f"ë¹„ë™ê¸° ìŒì„± ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")

def get_current_time():
    now = datetime.now()
    am_pm = "ì˜¤í›„" if now.hour >= 12 else "ì˜¤ì „"
    hour = now.hour - 12 if now.hour > 12 else (12 if now.hour == 0 else now.hour)
    return f"í˜„ì¬ ì‹œê°„ì€ {am_pm} {hour}ì‹œ {now.minute}ë¶„ì…ë‹ˆë‹¤."

def get_weather_forecast():
    try:
        lat, lon = 36.7836, 127.0000
        url = f"https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lon}&current=temperature_2m,wind_speed_10m"
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        data = response.json()
        temp = data['current']['temperature_2m']
        wind_speed_kmh = round(data['current']['wind_speed_10m'] * 3.6, 1)
        return f"í˜„ì¬ ì•„ì‚°ì‹œì˜ ê¸°ì˜¨ì€ {temp}ë„, í’ì†ì€ ì‹œì† {wind_speed_kmh} í‚¬ë¡œë¯¸í„°ì…ë‹ˆë‹¤."
    except: return "ë‚ ì”¨ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."

def get_response_text(command_info):
    target = command_info.get('target_name', '')
    action_type = command_info.get('action_type', '')
    def has_batchim(word):
        if not word: return False
        last_char = word[-1]
        if 'ê°€' <= last_char <= 'í£': return (ord(last_char) - ord('ê°€')) % 28 > 0
        return False
    target_eul_reul = target + 'ì„' if has_batchim(target) else target + 'ë¥¼'
    if action_type == 'execute': return f"ì•Œê² ìŠµë‹ˆë‹¤. {target_eul_reul} ì‹¤í–‰í•˜ê² ìŠµë‹ˆë‹¤."
    elif action_type == 'terminate': return f"ë„¤. {target_eul_reul} ì¢…ë£Œí•˜ê² ìŠµë‹ˆë‹¤."
    elif action_type == 'empty': return f"{target_eul_reul} ë¹„ìš°ê² ìŠµë‹ˆë‹¤."
    elif action_type == 'special' and target == 'ìŠ¤í¬ë¦°ìƒ·': return "ìŠ¤í¬ë¦°ìƒ·ì„ ì‹¤í–‰í•©ë‹ˆë‹¤."
    return f"{target} ëª…ë ¹ì„ ì‹¤í–‰í•©ë‹ˆë‹¤."

def execute(action_key):
    command_info = COMMANDS.get(action_key, {})
    cmd = command_info.get(platform.system().lower())
    action_type = command_info.get("action_type")
    if cmd:
        try:
            if action_type == 'execute':
                subprocess.Popen(cmd, shell=True)
            else:
                subprocess.run(cmd, shell=True, check=True, capture_output=True, text=True)
            return get_response_text(command_info)
        except Exception as e:
            print(f"'{action_key}' ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
            return f"{command_info.get('target_name', action_key)} ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."
    return "ì‹¤í–‰í•  ëª…ë ¹ì–´ê°€ ì—†ìŠµë‹ˆë‹¤."

def ask_gemini(prompt):
    try:
        response = gemini_model.generate_content(prompt)
        return response.text.strip().strip("'\".,")
    except Exception as e:
        print(f"ì˜¤ë¥˜: Gemini APIì™€ í†µì‹  ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ({e})")
        return "ì£„ì†¡í•©ë‹ˆë‹¤, ì§€ê¸ˆì€ ë‹µë³€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

# --- 4. ë©”ì¸ ë£¨í”„ ---
speak("ìë¹„ìŠ¤ ì˜¨ë¼ì¸, ì–´ë–»ê²Œ ë„ì™€ë“œë¦´ê¹Œìš”?")
while True:
    text = input("âŒ¨ï¸ ëª…ë ¹ì„ ì…ë ¥í•˜ì„¸ìš”: ")
    if not text.strip(): continue
    command_raw = text.replace("ìë¹„ìŠ¤", "").strip() if "ìë¹„ìŠ¤" in text else text.strip()
    if command_raw.lower() in ['ì¢…ë£Œ', 'exit', 'quit']:
        speak("ìë¹„ìŠ¤ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤. ì˜¤ëŠ˜ë„ ì¢‹ì€ í•˜ë£¨ ë˜ì„¸ìš”!")
        break
    print(f"ğŸ’¬ ì¸ì‹ëœ ëª…ë ¹: {command_raw}")
    final_command_key = None
    available_functions = list(COMMANDS.keys())
    function_descriptions = []
    for key, info in COMMANDS.items():
        description = f"- '{key}' (ê´€ë ¨ í‘œí˜„: {', '.join(info.get('aliases', []))})"
        function_descriptions.append(description)
    intent_prompt = (f"ë‹¹ì‹ ì€ ì‚¬ìš©ìì˜ ìì—°ì–´ ëª…ë ¹ì—ì„œ í•µì‹¬ ì˜ë„ë¥¼ íŒŒì•…í•˜ëŠ” AI ë‘ë‡Œì…ë‹ˆë‹¤. ë‹¤ìŒ 'ê¸°ëŠ¥ ì„¤ëª…'ì„ ì°¸ê³ í•˜ì—¬, ì£¼ì–´ì§„ 'ì‚¬ìš©ì ëª…ë ¹'ê³¼ ê°€ì¥ ì¼ì¹˜í•˜ëŠ” ê¸°ëŠ¥ì˜ ì´ë¦„(key) 'í•˜ë‚˜'ë§Œ ì •í™•íˆ ì¶œë ¥í•´ì£¼ì„¸ìš”.\n\n## ê¸°ëŠ¥ ì„¤ëª…:\n" + "\n".join(function_descriptions) + f"\n\n## ì§€ì‹œ:\nì í•©í•œ ê¸°ëŠ¥ì´ ìˆë‹¤ë©´ ê·¸ ê¸°ëŠ¥ì˜ ì´ë¦„ë§Œ, ì—†ë‹¤ë©´ 'NULL'ë§Œ ì¶œë ¥í•˜ì„¸ìš”.\n\n## ì‚¬ìš©ì ëª…ë ¹:\n\"{command_raw}\"")
    gemini_suggestion = ask_gemini(intent_prompt)
    if gemini_suggestion != "NULL" and gemini_suggestion in available_functions:
        final_command_key = gemini_suggestion
    result = ""
    if final_command_key:
        command_info = COMMANDS.get(final_command_key, {})
        action_type = command_info.get('action_type')
        if action_type == 'fetch_and_report':
            target_name = command_info.get('target_name')
            if target_name == 'í˜„ì¬ ë‚ ì”¨': result = get_weather_forecast()
            elif target_name == 'í˜„ì¬ ì‹œê°„': result = get_current_time()
        elif action_type == 'special':
            result = get_response_text(command_info)
            pyautogui.hotkey('win', 'shift', 's')
        elif action_type == 'empty':
            speak(f"ê²½ê³ , {command_info.get('target_name')}ì„(ë¥¼) ë¹„ìš°ë©´ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì •ë§ ì‹¤í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
            confirm = input("ì •ë§ ì‹¤í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/n): ")
            result = execute(final_command_key) if confirm.lower() == 'y' else "ì‹¤í–‰ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."
        else:
            result = execute(final_command_key)
    else:
        chat_prompt = f"ë‹¹ì‹ ì€ 'ìë¹„ìŠ¤'ë¼ëŠ” ì´ë¦„ì„ ê°€ì§„ AI ë¹„ì„œì…ë‹ˆë‹¤. ì‚¬ìš©ìì˜ ë‹¤ìŒ ë§ì— ëŒ€í•´ ìì—°ìŠ¤ëŸ½ê²Œ ëŒ€í™”í•˜ë“¯ ë‹µë³€í•´ì£¼ì„¸ìš”.ìì—°ìŠ¤ëŸ¬ìš´ ëŒ€í™”ì—ì„œ ë‹µë³€ì´ ë„ˆë¬´ ê¸¸ì§€ì•Šê²Œ ìµœëŒ€í•œ ì§§ê³  ê°„ê²°í•˜ê²Œ í•˜ì„¸ìš”.\n\nì‚¬ìš©ì: \"{command_raw}\"\nìë¹„ìŠ¤:"
        result = ask_gemini(chat_prompt) or f"'{command_raw}'ì— í•´ë‹¹í•˜ëŠ” ëª…ë ¹ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."
    if result:
        speak(result)

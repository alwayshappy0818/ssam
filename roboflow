# alfred.py (Python 3.11 ìµœì í™” ë²„ì „)
import io, os, sys, json, subprocess, platform, requests, asyncio, webbrowser, re, time, queue, urllib.parse
from datetime import datetime, timedelta
import edge_tts, pygame, speech_recognition as sr, tkinter as tk
from openai import OpenAI
from bs4 import BeautifulSoup
from tkinter import scrolledtext
import threading
import math
import numpy as np
import base64
import hashlib
import logging
import functools
from concurrent.futures import ThreadPoolExecutor, TimeoutError
from sentence_transformers import SentenceTransformer  # ë¡œì»¬ ì„ë² ë”© ëª¨ë¸
import glob
import importlib.util

class PluginManager:
    def __init__(self, alfred_app):
        self.alfred = alfred_app
        self.plugins = []
        self.plugin_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "plugins")
        
    def load_plugins(self):
        """í”ŒëŸ¬ê·¸ì¸ ë””ë ‰í† ë¦¬ì—ì„œ ëª¨ë“  í”ŒëŸ¬ê·¸ì¸ ë¡œë“œ"""
        if not os.path.exists(self.plugin_dir):
            os.makedirs(self.plugin_dir)
            self.alfred.add_message("ì‹œìŠ¤í…œ", "í”ŒëŸ¬ê·¸ì¸ ë””ë ‰í† ë¦¬ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤", "status_tag")
            return
            
        plugin_files = glob.glob(os.path.join(self.plugin_dir, "*.py"))
        for plugin_file in plugin_files:
            try:
                module_name = os.path.splitext(os.path.basename(plugin_file))[0]
                spec = importlib.util.spec_from_file_location(module_name, plugin_file)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                if hasattr(module, 'register_plugin'):
                    plugin_info = module.register_plugin(self.alfred)
                    if not isinstance(plugin_info, dict):
                        raise ValueError("register_pluginì€ dictë¥¼ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤")
                        
                    self.plugins.append(plugin_info)
                    self.alfred.add_message("ì‹œìŠ¤í…œ", 
                                          f"í”ŒëŸ¬ê·¸ì¸ ë¡œë“œ: {plugin_info.get('name', 'Unknown')} (v{plugin_info.get('version', '1.0')})",
                                          "status_tag")
            except Exception as e:
                self.alfred.add_message("ì‹œìŠ¤í…œ", 
                                      f"í”ŒëŸ¬ê·¸ì¸ ë¡œë“œ ì‹¤íŒ¨: {os.path.basename(plugin_file)} - {str(e)}",
                                      "status_tag")
                logger.error(f"í”ŒëŸ¬ê·¸ì¸ ë¡œë“œ ì˜¤ë¥˜: {plugin_file} - {e}")

    def handle_command(self, command: str) -> dict:
        """ëª…ë ¹ì–´ë¥¼ í”ŒëŸ¬ê·¸ì¸ì—ì„œ ì²˜ë¦¬"""
        for plugin in self.plugins:
            try:
                if 'handle_command' in plugin:
                    result = plugin['handle_command'](self.alfred, command)
                    if result and isinstance(result, dict):
                        return result
            except Exception as e:
                self.alfred.add_message("ì‹œìŠ¤í…œ", 
                                      f"í”ŒëŸ¬ê·¸ì¸ ì˜¤ë¥˜: {plugin.get('name', 'Unknown')} - {str(e)}",
                                      "status_tag")
                logger.error(f"í”ŒëŸ¬ê·¸ì¸ ì‹¤í–‰ ì˜¤ë¥˜: {plugin.get('name', 'Unknown')} - {e}")
        return None
# ë¡œê¹… ì„¤ì •
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('Alfred')

# ì„ë² ë”© ê¸°ë°˜ ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œ (ë¡œì»¬ ëª¨ë¸ ì‚¬ìš©)
class EmbeddingMemory:
    def __init__(self):
        self.embeddings = []  # ì„ë² ë”© ë²¡í„° ì €ì¥
        self.documents = []    # ì›ë³¸ ë¬¸ì„œ ì €ì¥
        self.cache = {}        # ì„ë² ë”© ìºì‹œ (í…ìŠ¤íŠ¸ í•´ì‹œ -> ì„ë² ë”©)
        self.model = None      # ë¡œì»¬ ì„ë² ë”© ëª¨ë¸
        
    def load_local_model(self):
        """ë¡œì»¬ ì„ë² ë”© ëª¨ë¸ ë¡œë“œ"""
        try:
            # ê²½ëŸ‰ í•œêµ­ì–´ ì„ë² ë”© ëª¨ë¸ (CPU ì „ìš©ìœ¼ë¡œ ë¡œë“œ)
            self.model = SentenceTransformer(
                'sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2',
                device='cpu'
            )
            logger.info("ë¡œì»¬ ì„ë² ë”© ëª¨ë¸ ë¡œë“œ ì™„ë£Œ")
            return True
        except Exception as e:
            logger.error(f"ë¡œì»¬ ì„ë² ë”© ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨: {e}")
            self.model = None
            return False
    
    def get_embedding(self, text):
        """í…ìŠ¤íŠ¸ì˜ ì„ë² ë”©ì„ ê°€ì ¸ì˜¤ê±°ë‚˜ ìºì‹œì—ì„œ ë°˜í™˜"""
        if not text:
            return np.zeros(384).tolist()  # ê¸°ë³¸ ì°¨ì› (MiniLM-L12-v2ëŠ” 384ì°¨ì›)
        
        # í…ìŠ¤íŠ¸ í•´ì‹œ ìƒì„±
        text_hash = hashlib.sha256(text.encode('utf-8')).hexdigest()
        
        # ìºì‹œì— ì¡´ì¬í•˜ë©´ ë°˜í™˜
        if text_hash in self.cache:
            return self.cache[text_hash]
        
        # ë¡œì»¬ ëª¨ë¸ë¡œ ì„ë² ë”© ìƒì„±
        if self.model:
            try:
                # í…ìŠ¤íŠ¸ ê¸¸ì´ ì œí•œ (ì„±ëŠ¥ í–¥ìƒ)
                truncated_text = text[:512]  # 512í† í°ìœ¼ë¡œ ì œí•œ
                embedding = self.model.encode(truncated_text).tolist()
                self.cache[text_hash] = embedding
                return embedding
            except Exception as e:
                logger.error(f"ë¡œì»¬ ì„ë² ë”© ìƒì„± ì˜¤ë¥˜: {e}")
        
        # ì˜¤ë¥˜ ì‹œ 0 ë²¡í„° ë°˜í™˜
        return np.zeros(384).tolist()
    
    def add_document(self, text):
        """ìƒˆ ë¬¸ì„œ ì¶”ê°€"""
        if not text or len(text) < 5:
            return
            
        embedding = self.get_embedding(text)
        self.documents.append(text)
        self.embeddings.append(embedding)
        
        # ìµœëŒ€ 300ê°œ ë¬¸ì„œ ìœ ì§€ (ë©”ëª¨ë¦¬ ì ˆì•½)
        if len(self.documents) > 300:
            self.documents.pop(0)
            self.embeddings.pop(0)
    
    def cosine_similarity(self, vec1, vec2):
        """ë‘ ë²¡í„° ê°„ì˜ ì½”ì‚¬ì¸ ìœ ì‚¬ë„ ê³„ì‚° (ìˆ˜ì¹˜ ì•ˆì •ì„± ê°•í™”)"""
        vec1 = np.array(vec1)
        vec2 = np.array(vec2)
        norm1 = np.linalg.norm(vec1)
        norm2 = np.linalg.norm(vec2)
        
        if norm1 == 0 or norm2 == 0:
            return 0
            
        # ì‘ì€ ê°’ ì¶”ê°€ë¡œ ìˆ˜ì¹˜ ì•ˆì •ì„± í™•ë³´
        epsilon = 1e-8
        return np.dot(vec1, vec2) / ((norm1 * norm2) + epsilon)
    
    def retrieve_similar(self, query, n_results=3):
        """ì¿¼ë¦¬ì™€ ìœ ì‚¬í•œ ë¬¸ì„œ ê²€ìƒ‰"""
        if not self.documents:
            return []
            
        # ì¿¼ë¦¬ ì„ë² ë”© ìƒì„±
        query_embedding = self.get_embedding(query)
        
        # ìœ ì‚¬ë„ ê³„ì‚° (ë°°ì¹˜ ì²˜ë¦¬ë¡œ ì„±ëŠ¥ í–¥ìƒ)
        scores = []
        batch_size = 50
        total_docs = len(self.embeddings)
        
        for i in range(0, total_docs, batch_size):
            batch_embeddings = self.embeddings[i:i+batch_size]
            batch_scores = [self.cosine_similarity(query_embedding, emb) for emb in batch_embeddings]
            scores.extend(batch_scores)
        
        # ìƒìœ„ n_resultsê°œ ë¬¸ì„œ ë°˜í™˜ (ìœ ì‚¬ë„ 0.6 ì´ìƒë§Œ)
        indexed_scores = [(score, i) for i, score in enumerate(scores)]
        indexed_scores.sort(key=lambda x: x[0], reverse=True)
        
        results = []
        for score, idx in indexed_scores[:n_results]:
            if score > 0.6:
                results.append(self.documents[idx])
        return results

# ì‚¬ìš©ì í”„ë¡œí•„ í´ë˜ìŠ¤ (ë³€ê²½ ì—†ìŒ)
class UserProfile:
    def __init__(self, profile_path="user_profile.json"):
        self.profile_path = profile_path
        self.profile = self.load_profile()
        
    def load_profile(self):
        try:
            if os.path.exists(self.profile_path):
                with open(self.profile_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            return {"personal_facts": {}, "preferences": {}}
        except Exception:
            return {"personal_facts": {}, "preferences": {}}
            
    def save_profile(self):
        try:
            with open(self.profile_path, 'w', encoding='utf-8') as f:
                json.dump(self.profile, f, ensure_ascii=False, indent=2)
            return True
        except Exception as e:
            logger.error(f"í”„ë¡œí•„ ì €ì¥ ì˜¤ë¥˜: {e}")
            return False
            
    def update_profile(self, new_data):
        for category, data in new_data.items():
            if category not in self.profile:
                self.profile[category] = {}
            self.profile[category].update(data)
        self.save_profile()
        
    def get_context(self):
        context = []
        if self.profile["personal_facts"]:
            context.append("[ì‚¬ìš©ì ì •ë³´]")
            for key, value in self.profile["personal_facts"].items():
                context.append(f"- {key}: {value}")
        if self.profile["preferences"]:
            context.append("\n[ì‚¬ìš©ì ì„ í˜¸ë„]")
            for key, value in self.profile["preferences"].items():
                context.append(f"- {key}: {value}")
        return "\n".join(context) if context else ""

if platform.system() == 'Windows':
    try:
        import win32gui, uiautomation as auto, pythoncom
    except ImportError:
        auto, win32gui, pythoncom = None, None, None
else:
    auto, win32gui, pythoncom = None, None, None

# íƒ€ì„ì•„ì›ƒ ë°ì½”ë ˆì´í„° ì¶”ê°€
def timeout(seconds=15):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            with ThreadPoolExecutor(max_workers=1) as executor:
                future = executor.submit(func, *args, **kwargs)
                try:
                    return future.result(timeout=seconds)
                except TimeoutError:
                    instance = args[0]  # self ì¸ìŠ¤í„´ìŠ¤
                    instance.add_message("ì‹œìŠ¤í…œ", "âš ï¸ ëª…ë ¹ ì²˜ë¦¬ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤", "status_tag")
                    return None
        return wrapper
    return decorator

class App(tk.Tk):
    def show_plugins(self):
        if not self.plugin_manager.plugins:
            self.add_message("ì‹œìŠ¤í…œ", "ë¡œë“œëœ í”ŒëŸ¬ê·¸ì¸ì´ ì—†ìŠµë‹ˆë‹¤", "status_tag")
            return
            
        plugin_list = "\n".join(
            f"- {p['name']} (v{p.get('version', '1.0')})" 
            for p in self.plugin_manager.plugins
        )
        self.add_message("ì‹œìŠ¤í…œ", f"ë¡œë“œëœ í”ŒëŸ¬ê·¸ì¸:\n{plugin_list}", "status_tag")

    def __init__(self):
        super().__init__()
        self.protocol("WM_DELETE_WINDOW", self.close_app)
        self.running = True
        self.is_listening = True
        self.is_speaking = threading.Event()
        self.conversation_context = {"active_tab": {"title": "", "url": ""}}
        self.conversation_history = []
        self.gui_queue = queue.Queue()
        self.context_lock = threading.Lock()
        self.active_threads = {}  # ì‘ë‹µ ì—†ëŠ” ìŠ¤ë ˆë“œ ê°ì§€ìš©
        self.plugin_manager = PluginManager(self)
        self.plugin_manager.load_plugins()       
        # ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œ ì´ˆê¸°í™” (ë¡œì»¬ ì„ë² ë”© ê¸°ë°˜)
        self.memory_model = EmbeddingMemory()
        self.memory_model.load_local_model()  # ë¡œì»¬ ëª¨ë¸ ë¡œë“œ
        
        # ì‚¬ìš©ì í”„ë¡œí•„ ì´ˆê¸°í™”
        self.user_profile = UserProfile()
        
        try:
            # Windows ì˜¤ë””ì˜¤ ë“œë¼ì´ë²„ ë¬¸ì œ í•´ê²°
            if platform.system() == "Windows":
                os.environ["SDL_AUDIODRIVER"] = "directsound"
            
            # Pygame ì•ˆì „ ì´ˆê¸°í™”
            if not pygame.get_init():
                pygame.mixer.init(buffer=1024)
            
            script_dir = os.path.dirname(os.path.abspath(__file__))
            
            # ë©”ëª¨ë¦¬ íŒŒì¼ ê²½ë¡œ ì„¤ì •
            self.memory_path = os.path.join(script_dir, 'memory.json')
            self.load_memory()  # ì•± ì‹œì‘ ì‹œ ê³¼ê±° ëŒ€í™” ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
            
            config_path = os.path.join(script_dir, 'config.json')
            if os.path.exists(config_path):
                with open(config_path, 'r', encoding='utf-8') as f: 
                    self.CONFIG = json.load(f)
            else:
                self.CONFIG = {
                    "DEEPSEEK_API_KEY": "YOUR API KEY",
                    "DEEPSEEK_MODEL": "deepseek/deepseek-chat-v3-0324:free",
                    "USER_NAME": "ì‚¬ìš©ì",
                    "USE_API_FOR_MEMORY": False,  # API ì‚¬ìš© ì—¬ë¶€ í”Œë˜ê·¸
                    "SHOW_SYSTEM_MESSAGES": False,  # ì‹œìŠ¤í…œ ë©”ì‹œì§€ í‘œì‹œ ì—¬ë¶€
                    "WEATHER_API_KEY": "YOUR_WEATHER_API_KEY"  # ë‚ ì”¨ API í‚¤
                }
                with open(config_path, 'w', encoding='utf-8') as f: 
                    json.dump(self.CONFIG, f, indent=4)
            
            json_path = os.path.join(script_dir, 'commands.json')
            with open(json_path, encoding="utf-8") as f: 
                self.COMMANDS = json.load(f)
            
            self.client = OpenAI(
                api_key=self.CONFIG.get("DEEPSEEK_API_KEY"),
                base_url="https://openrouter.ai/api/v1"
            )
            self.VOICE = "ko-KR-SunHiNeural"
            self.RATE = "+70%"
        except Exception as e:
            logger.error(f"ì´ˆê¸°í™” ì˜¤ë¥˜: {e}")
            self.destroy()
            sys.exit(1)
        
        # GUI ì„¤ì •
        self.title("ì•Œí”„ë ˆë“œ")
        self.geometry("600x700")
        self.configure(bg="#121212")
        self.output_area = scrolledtext.ScrolledText(
            self, wrap=tk.WORD, bg="#1E1E1E", fg="#E0E0E0", 
            font=("Malgun Gothic", 10), relief=tk.FLAT, 
            borderwidth=0, padx=10, pady=10
        )
        self.output_area.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.output_area.config(state=tk.DISABLED)
        self.output_area.tag_config("user_tag", foreground="#FFD700", font=("Malgun Gothic", 10, "bold"))
        self.output_area.tag_config("assistant_tag", foreground="#87CEEB", font=("Malgun Gothic", 10, "bold"))
        self.output_area.tag_config("status_tag", foreground="#AAAAAA", font=("Malgun Gothic", 9, "italic"))
        self.output_area.tag_config("memory_tag", foreground="#98FB98", font=("Malgun Gothic", 9))
        
        input_frame = tk.Frame(self, bg="#121212")
        input_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.input_field = tk.Entry(
            input_frame, bg="#2C2C2C", fg="#E0E0E0", 
            font=("Malgun Gothic", 10), relief=tk.FLAT, 
            insertbackground="white"
        )
        self.input_field.pack(side=tk.LEFT, fill=tk.X, expand=True, ipady=5, padx=(0, 5))
        self.input_field.bind("<Return>", lambda event: self.send_command())
        
        button_frame = tk.Frame(input_frame, bg="#121212")
        button_frame.pack(side=tk.LEFT)
        
        self.voice_button = tk.Button(
            button_frame, text="ğŸ¤", command=self.toggle_voice_input, 
            bg="#4CAF50", fg="white", relief="flat", width=4
        )
        self.voice_button.pack(side=tk.LEFT, padx=2)
        
        self.stop_button = tk.Button(
            button_frame, text="ğŸ”‡", command=self.stop_speech, 
            bg="#FF9800", fg="white", relief="flat", width=4
        )
        self.stop_button.pack(side=tk.LEFT, padx=2)
        
        self.exit_button = tk.Button(
            button_frame, text="ğŸšª", command=self.close_app, 
            bg="#F44336", fg="white", relief="flat", width=4
        )
        self.exit_button.pack(side=tk.LEFT, padx=2)
        
        # ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ ì‹œì‘
        threading.Thread(target=self.voice_input_worker, daemon=True).start()
        threading.Thread(target=self.monitor_threads, daemon=True).start()  # ìŠ¤ë ˆë“œ ëª¨ë‹ˆí„°ë§
        self.after(100, self.check_gui_queue)
        
        if platform.system() == "Windows" and auto is not None:
            threading.Thread(target=self.monitor_active_tab, daemon=True).start()
        
        if self.CONFIG.get("SHOW_SYSTEM_MESSAGES", False):
            self.gui_queue.put({'type': 'update_voice_button', 'text': "ğŸ¤...", 'bg': "#FFC107"})
            self.add_message("ì‹œìŠ¤í…œ", "ë“£ê³  ìˆìŠµë‹ˆë‹¤...", "status_tag")
        self.after(500, self.initial_greeting)

    def monitor_threads(self):
        """ì‘ë‹µ ì—†ëŠ” ìŠ¤ë ˆë“œ ê°ì§€"""
        while self.running:
            time.sleep(10)
            current_time = time.time()
            for tid, start_time in list(self.active_threads.items()):
                if current_time - start_time > 60:  # 60ì´ˆ ì´ìƒ ì‹¤í–‰ ì¤‘
                    logger.warning(f"ì‘ë‹µ ì—†ëŠ” ìŠ¤ë ˆë“œ ê°ì§€: {tid}")
                    del self.active_threads[tid]
                    self.add_message("ì‹œìŠ¤í…œ", "âš ï¸ ëª…ë ¹ ì²˜ë¦¬ ì§€ì—°ìœ¼ë¡œ ì¬ì‹œì‘í•©ë‹ˆë‹¤", "status_tag")

    def load_memory(self):
        """ì•± ì‹œì‘ ì‹œ memory.json íŒŒì¼ì—ì„œ ëŒ€í™” ê¸°ë¡ì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤."""
        try:
            if os.path.exists(self.memory_path):
                with open(self.memory_path, 'r', encoding='utf-8') as f:
                    self.conversation_history = json.load(f)
                    logger.info(f"ê¸°ì–µ ë¡œë“œ ì™„ë£Œ: {len(self.conversation_history)}ê°œì˜ ëŒ€í™” ê¸°ë¡ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.")
                    
                    # ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œì— ê¸°ë¡ ì¶”ê°€
                    self._add_to_memory(self.conversation_history)
            else:
                self.conversation_history = []
                logger.info("memory.json íŒŒì¼ì´ ì—†ì–´ ìƒˆë¡œìš´ ëŒ€í™” ê¸°ë¡ì„ ì‹œì‘í•©ë‹ˆë‹¤.")
        except (json.JSONDecodeError, IOError) as e:
            logger.error(f"ê¸°ì–µ ë¡œë“œ ì‹¤íŒ¨: {e}")
            self.conversation_history = []
        except Exception as e:
            logger.error(f"ê¸°ì–µ ë¡œë“œ ì¤‘ ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜: {e}")
            self.conversation_history = []
    
    def _add_to_memory(self, messages):
        """ëŒ€í™” ê¸°ë¡ì„ ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œì— ì¶”ê°€"""
        for msg in messages:
            if msg["role"] in ["user", "assistant"] and len(msg["content"]) > 10:
                text = msg["content"]
                self.memory_model.add_document(text)
        logger.info(f"ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œì— {len(messages)}ê°œ ê¸°ë¡ ì¶”ê°€ ì™„ë£Œ")

    def save_memory(self):
        """ì•± ì¢…ë£Œ ì‹œ í˜„ì¬ ëŒ€í™” ê¸°ë¡ì„ memory.json íŒŒì¼ì— ì €ì¥í•©ë‹ˆë‹¤."""
        logger.info("\n--- [ë©”ëª¨ë¦¬ ì €ì¥ ì‹œì‘] ---")
        try:
            # ì €ì¥í•  ë””ë ‰í† ë¦¬ í™•ì¸ ë° ìƒì„±
            memory_dir = os.path.dirname(self.memory_path)
            if not os.path.exists(memory_dir):
                os.makedirs(memory_dir)
                logger.info(f"ë””ë ‰í† ë¦¬ ìƒì„±: {memory_dir}")
            
            # ìµœê·¼ 50ê°œ ëŒ€í™”ë§Œ ì €ì¥ (ë©”ëª¨ë¦¬ íš¨ìœ¨í™”)
            history_to_save = self.conversation_history[-50:]
            
            if not history_to_save:
                logger.info("ì €ì¥í•  ëŒ€í™” ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.")
                return
                
            # íŒŒì¼ì— ì•ˆì „í•˜ê²Œ ì €ì¥
            with open(self.memory_path, 'w', encoding='utf-8') as f:
                json.dump(history_to_save, f, ensure_ascii=False, indent=4)
                f.flush()  # ë²„í¼ ë¹„ìš°ê¸°
                os.fsync(f.fileno())  # ë””ìŠ¤í¬ì— ë™ê¸°í™”
                
            logger.info(f"ì„±ê³µ: {len(history_to_save)}ê°œ ëŒ€í™” ê¸°ë¡ ì €ì¥ ì™„ë£Œ")
            
        except Exception as e:
            logger.error(f"!!! ë©”ëª¨ë¦¬ ì €ì¥ ì‹¤íŒ¨: {e} !!!")
            # ì˜¤ë¥˜ ë°œìƒ ì‹œ ìµœì†Œí•œì˜ ë°±ì—… ì‹œë„
            try:
                backup_path = f"{self.memory_path}.bak"
                with open(backup_path, 'w', encoding='utf-8') as f:
                    json.dump(self.conversation_history, f)
                logger.info(f"ë°±ì—… íŒŒì¼ ìƒì„±: {backup_path}")
            except Exception as backup_error:
                logger.error(f"ë°±ì—… ìƒì„± ì‹¤íŒ¨: {backup_error}")

    def retrieve_memories(self, query, n_results=3):
        """AI ì„ë² ë”© ê¸°ë°˜ìœ¼ë¡œ ê´€ë ¨ ê¸°ì–µ ê²€ìƒ‰"""
        return self.memory_model.retrieve_similar(query, n_results)

    def extract_user_facts(self, user_input, assistant_response):
        """ì‚¬ìš©ì ì…ë ¥ì—ì„œ ê°œì¸ ì •ë³´ ì¶”ì¶œ (API í˜¸ì¶œ ìµœì†Œí™”)"""
        # ê°„ë‹¨í•œ íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ ê¸°ë³¸ ì •ë³´ ì¶”ì¶œ ì‹œë„
        patterns = {
            "ì´ë¦„": r"ë‚´ ì´ë¦„ì€ (.+?)[\s\.]",
            "ë‚˜ì´": r"ë‚˜ëŠ” (\d+)ì‚´ì´ì•¼",
            "ê±°ì£¼ì§€": r"ë‚˜ëŠ” (.+?)ì— ì‚´ì•„",
            "ì§ì—…": r"ë‚´ ì§ì—…ì€ (.+?)[\s\.]"
        }
        
        extracted = {}
        for key, pattern in patterns.items():
            match = re.search(pattern, user_input)
            if match:
                extracted[key] = match.group(1)
        
        # ì¶”ì¶œëœ ì •ë³´ê°€ ìˆì„ ê²½ìš° ë°˜í™˜
        if extracted:
            return {"personal_facts": extracted}
        
        # ì •ë³´ê°€ ì—†ì„ ë•Œë§Œ API í˜¸ì¶œ
        if not self.CONFIG.get("USE_API_FOR_MEMORY", False):
            return {}
            
        prompt = (
            "ë‹¤ìŒ ëŒ€í™”ì—ì„œ ì‚¬ìš©ìì— ëŒ€í•œ ìƒˆë¡œìš´ ì‚¬ì‹¤ì„ ì¶”ì¶œí•˜ì„¸ìš”. "
            "JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µí•˜ê³ , ìƒˆë¡œìš´ ì •ë³´ê°€ ì—†ìœ¼ë©´ ë¹ˆ ê°ì²´ë¥¼ ë°˜í™˜í•˜ì„¸ìš”.\n\n"
            f"ì‚¬ìš©ì: {user_input}\n"
            f"ì–´ì‹œìŠ¤í„´íŠ¸: {assistant_response}\n\n"
            "ì˜ˆì‹œ: {\"personal_facts\": {\"ê±°ì£¼ì§€\": \"ì•„ì‚°\"}, \"preferences\": {\"ìŒì‹\": \"í”¼ì\"}}"
        )
        
        try:
            response = self.client.chat.completions.create(
                model=self.CONFIG["DEEPSEEK_MODEL"],
                messages=[{"role": "user", "content": prompt}],
                response_format={"type": "json_object"},
                max_tokens=200
            )
            
            facts = json.loads(response.choices[0].message.content)
            return facts
        except Exception as e:
            logger.error(f"ì‚¬ìš©ì ì •ë³´ ì¶”ì¶œ ì˜¤ë¥˜: {e}")
            return {}

    def analyze_command_logic(self, command_raw, is_follow_up=False):
        # 0. í”ŒëŸ¬ê·¸ì¸ì—ì„œ ëª…ë ¹ ì²˜ë¦¬ ì‹œë„
        plugin_result = self.plugin_manager.handle_command(command_raw)
        if plugin_result:
            return plugin_result        
        
        # 1. ëª¨í˜¸í•œ í›„ì† ì§ˆë¬¸ ì²˜ë¦¬
        follow_up_keywords = ["ê·¸ ì‚¬ëŒ", "ê·¸ê±°", "ê±°ê¸°ì„œ", "ì €ê²ƒë„", "ì˜ì–´ë¡œë„", "ì¼ë³¸ì–´ë¡œë„", 
                             "ë‹¤ì‹œ í•œë²ˆ", "ìì„¸íˆ", "ì•„ë‹ˆ", "ë§ê³ ", "ë‹¤ë¥¸"]
        is_ambiguous = any(keyword in command_raw for keyword in follow_up_keywords) or len(command_raw.split()) <= 3

        # í›„ì† ì§ˆë¬¸ì´ê³ , ì¬ê·€ í˜¸ì¶œì´ ì•„ë‹ ë•Œë§Œ ë¬¸ë§¥ ì¶”ë¡  ì‹œë„
        if is_ambiguous and not is_follow_up and self.conversation_history:
            logger.info("ëª¨í˜¸í•œ ì§ˆë¬¸ ê°ì§€. ë¬¸ë§¥ ì¶”ë¡ ì„ ì‹œì‘í•©ë‹ˆë‹¤.")
            
            # í˜„ì¬ ë¸Œë¼ìš°ì € ì»¨í…ìŠ¤íŠ¸ í¬í•¨
            context_info = ""
            with self.context_lock:
                if self.conversation_context["active_tab"]["url"]:
                    context_info = (
                        f"\n[í˜„ì¬ ë¸Œë¼ìš°ì§• ì»¨í…ìŠ¤íŠ¸]\n"
                        f"ì œëª©: {self.conversation_context['active_tab']['title']}\n"
                        f"URL: {self.conversation_context['active_tab']['url']}\n"
                    )
            
            # ìµœê·¼ ëŒ€í™”ì—ì„œ ë§ˆì§€ë§‰ ì‚¬ìš©ì ëª…ë ¹ê³¼ ì–´ì‹œìŠ¤í„´íŠ¸ ì‘ë‹µ ì¶”ì¶œ
            last_user_command = ""
            last_assistant_response = ""
            for msg in reversed(self.conversation_history):
                if msg["role"] == "user":
                    last_user_command = msg["content"]
                    break
                elif msg["role"] == "assistant":
                    last_assistant_response = msg["content"]
            
            history_str = "\n".join([f"{msg['role']}: {msg['content']}" for msg in self.conversation_history[-4:]])
            prompt = (
                f"ë‹¤ìŒì€ ì‚¬ìš©ìì™€ì˜ ìµœê·¼ ëŒ€í™” ë‚´ìš©ì…ë‹ˆë‹¤:{context_info}\n"
                f"--- ëŒ€í™” ì‹œì‘ ---\n{history_str}\n--- ëŒ€í™” ë ---\n\n"
                f"ì´ ë¬¸ë§¥ì„ ë°”íƒ•ìœ¼ë¡œ, ì‚¬ìš©ìì˜ ë‹¤ìŒ ëª¨í˜¸í•œ ìš”ì²­ì„ ì™„ì „í•œ ëª…ë ¹ì–´ë¡œ ë°”ê¿”ì£¼ì„¸ìš”.\n"
                f"ì´ì „ ì‚¬ìš©ì ëª…ë ¹: '{last_user_command}'\n"
                f"ì´ì „ ì–´ì‹œìŠ¤í„´íŠ¸ ì‘ë‹µ: '{last_assistant_response}'\n"
                f"í˜„ì¬ ì‚¬ìš©ìì˜ ëª¨í˜¸í•œ ìš”ì²­: '{command_raw}'\n"
                f"ì™„ì„±ëœ ëª…ë ¹ì–´:"
            )
            
            completed_command = self.ask_ai([{"role": "user", "content": prompt}])
            completed_command = completed_command.strip().strip('"').strip("'")
            logger.info(f"ì¶”ë¡ ëœ ëª…ë ¹ì–´: {completed_command}")
            if self.CONFIG.get("SHOW_SYSTEM_MESSAGES", False):
                self.add_message("ì‹œìŠ¤í…œ", f"(ì¶”ë¡ ëœ ëª…ë ¹ì–´: {completed_command})", "status_tag")
            
            # ì™„ì„±ëœ ëª…ë ¹ì–´ë¡œ ì¬ë¶„ì„
            return self.analyze_command_logic(completed_command, is_follow_up=True)

        # --- ì´í•˜ëŠ” ëª…í™•í•œ ëª…ë ¹ì–´ ì²˜ë¦¬ ë¡œì§ ---
        lang_map = {'ì˜ì–´': 'English', 'ì¼ë³¸ì–´': 'Japanese', 'ì¤‘êµ­ì–´': 'Chinese'}
        platform_map = {'ì¿ íŒ¡': 'coupang', 'ìœ íŠœë¸Œ': 'youtube', 'ë„¤ì´ë²„': 'naver', 'êµ¬ê¸€': 'google'}

        # 2. í”Œë«í¼ + ë²ˆì—­ ê²€ìƒ‰ íŒ¨í„´ (ê°€ì¥ êµ¬ì²´ì ì¸ ëª…ë ¹ ë¨¼ì €)
        for platform_kw, platform_id in platform_map.items():
            for lang_kw in lang_map.keys():
                # ê°œì„ ëœ ì •ê·œì‹: ê²€ìƒ‰ì–´ ë¶€ë¶„ì„ ë” ì •í™•íˆ ì¶”ì¶œ
                pattern = rf'{platform_kw}(ì—ì„œ|ì—)?\s*"?([^"]+?)"?\s*(?:ë¥¼|ì„)?\s*{lang_kw}ë¡œ\s*(ê²€ìƒ‰|ì°¾ì•„ì¤˜|ì•Œë ¤ì¤˜)'
                match = re.search(pattern, command_raw)
                if match:
                    query = match.group(2).strip()
                    query = re.sub(r'(ì´ë¼ê³ |ë¼ê³ |ì„|ë¥¼)$', '', query).strip()
                    return {'type': 'platform_translate_search', 'platform': platform_id, 'query': query, 'lang_ko': lang_kw, 'platform_kr': platform_kw}

        # 3. í”Œë«í¼ ê²€ìƒ‰ íŒ¨í„´
        for platform_kw, platform_id in platform_map.items():
            pattern = rf'({platform_kw})(ì—ì„œ|ì—)?\s*"?([^"]+?)"?\s*(ê²€ìƒ‰í•´ì¤˜|ì°¾ì•„ì¤˜|ì•Œë ¤ì¤˜|ê²€ìƒ‰í•´ ì¤˜|ê²€ìƒ‰)'
            match = re.search(pattern, command_raw)
            if match:
                query = match.group(3).strip()
                query = re.sub(r'(ì´ë¼ê³ |ë¼ê³ |ì„|ë¥¼)$', '', query).strip()
                return {'type': 'platform_search', 'platform': platform_id, 'query': query, 'platform_kr': platform_kw}

        # 4. ë²ˆì—­ ê²€ìƒ‰ íŒ¨í„´
        match = re.search(r'"?([^"]+)"?\s*(?:ë¥¼|ì„)\s*(\S+ì–´)ë¡œ\s*(ê²€ìƒ‰|ì°¾ì•„ì¤˜|ì•Œë ¤ì¤˜)', command_raw)
        if match:
            query, lang_ko, _ = match.groups()
            return {'type': 'translate_and_search', 'query': query.strip(), 'lang_ko': lang_ko, 'lang_en': lang_map[lang_ko]}

        # 5. ë‚ ì”¨ ì¡°íšŒ íŒ¨í„´ (ì¶”ê°€)
        #weather_patterns = [
        #    r'(ì˜¤ëŠ˜|ë‚´ì¼|ëª¨ë ˆ)\s*ë‚ ì”¨\s*(ì•Œë ¤ì¤˜|ì–´ë•Œ|ë³´ì—¬ì¤˜)',
        #    r'(.*?)\s*ë‚ ì”¨\s*(ì•Œë ¤ì¤˜|ì–´ë•Œ|ë³´ì—¬ì¤˜)'
        #]
        
        #for pattern in weather_patterns:
        #    match = re.search(pattern, command_raw)
        #    if match:
        #        forecast_type = match.group(1) if match.group(1) in ['ì˜¤ëŠ˜', 'ë‚´ì¼', 'ëª¨ë ˆ'] else 'í˜„ì¬'
        #        location = match.group(1) if pattern == weather_patterns[1] and match.group(1) and match.group(1) not in ['ì˜¤ëŠ˜', 'ë‚´ì¼', 'ëª¨ë ˆ'] else None
        #        return {'type': 'weather', 'location': location, 'forecast': forecast_type}

        # 6. ì¼ë°˜ ëª…ë ¹ì–´ íŒ¨í„´ (ê°€ì¥ ê¸´ í‚¤ì›Œë“œ ìš°ì„ )
        best_match = None
        for key, info in self.COMMANDS.items():
            if key.startswith("##"): continue
            if 'aliases' in info:
                for alias in info['aliases']:
                    if alias in command_raw:
                        if best_match is None or len(alias) > len(best_match['alias']):
                            best_match = {'info': info, 'alias': alias}
        if best_match:
            return {'type': best_match['info'].get("action_type", "chat"), 'command_info': best_match['info']}

        # 7. ì¢…ë£Œ ëª…ë ¹ì–´
        if any(kw in command_raw.lower() for kw in ["ì¢…ë£Œí•´", "ìˆ˜ê³ í–ˆì–´", "ì˜ê°€", "ë‚˜ê°€ê¸°"]): return {'type': 'exit'}
        
        # 8. ê°„ë‹¨í•œ ì¸ì‚¬ ì²˜ë¦¬ (API í˜¸ì¶œ ë°©ì§€)
        greetings = ["ì•ˆë…•", "ì•ˆë…•í•˜ì„¸ìš”", "í•˜ì´", "ë°˜ê°€ì›Œ", "ì˜ ì§€ëƒˆì–´", "ë­í•´"]
        if any(greeting in command_raw for greeting in greetings):
            return {'type': 'greeting'}

        # 9. ì¼ë°˜ ëŒ€í™” (ì¥ê¸°ê¸°ì–µ ì—°ë™)
        system_prompt = (
            "You are 'Alfred', a helpful and concise AI assistant. "
            "Your primary response language is Korean. "
            "Do not use emojis. Provide clear and direct answers. "
            f"Current user: {self.CONFIG.get('USER_NAME', 'ì‚¬ìš©ì')}."
        )
        
        # ì‚¬ìš©ì í”„ë¡œí•„ ì •ë³´ ì¶”ê°€
        profile_context = self.user_profile.get_context()
        if profile_context:
            system_prompt += f"\n\n{profile_context}"
        
        # ì¥ê¸°ê¸°ì–µì—ì„œ ê´€ë ¨ ê¸°ì–µ ê²€ìƒ‰
        related_memories = self.retrieve_memories(command_raw)
        if related_memories:
            memory_context = "\n".join([f"ê´€ë ¨ ê¸°ì–µ: {mem}" for mem in related_memories])
            system_prompt += f"\n\n[ê³¼ê±° ëŒ€í™” ê¸°ë¡]\n{memory_context}"
            if self.CONFIG.get("SHOW_SYSTEM_MESSAGES", False):
                self.add_message("ê¸°ì–µ ì‹œìŠ¤í…œ", memory_context, "memory_tag")
        
        # ì¥ê¸°ê¸°ì–µì—ì„œ ìµœê·¼ 5ê°œ + ì „ì²´ ëŒ€í™”ì—ì„œ ìµœê·¼ 5ê°œ ì¡°í•©
        recent_history = self.conversation_history[-5:]
        messages = [{"role": "system", "content": system_prompt}] + recent_history + [{"role": "user", "content": command_raw}]
        return {'type': 'chat', 'messages': messages}

    @timeout(15)  # 15ì´ˆ íƒ€ì„ì•„ì›ƒ ì ìš©
    def process_command(self, command, is_internal=False):
        # ìŠ¤ë ˆë“œ ì¶”ì  ì‹œì‘
        tid = threading.get_ident()
        self.active_threads[tid] = time.time()
        
        try:
            if not is_internal:
                self.conversation_history.append({"role": "user", "content": command})
                self.gui_queue.put({'type': 'update_voice_button', 'text': "ğŸ¤”", 'bg': "#607D8B"})
            
            plan = self.analyze_command_logic(command)
            response_text = ""
            action_type = plan.get('type')
            
            if action_type == 'platform_search':
                platform = plan['platform']
                query = plan['query']
                platform_kr = plan['platform_kr']
                url_templates = {
                    'coupang': "https://www.coupang.com/np/search?q={query}",
                    'youtube': "https://www.youtube.com/results?search_query={query}",
                    'naver': "https://search.naver.com/search.naver?query={query}",
                    'google': "https://www.google.com/search?q={query}"
                }
                if platform in url_templates:
                    encoded_query = urllib.parse.quote(query)
                    url = url_templates[platform].format(query=encoded_query)
                    webbrowser.open(url)
                    response_text = f"ì•Œê² ìŠµë‹ˆë‹¤. {platform_kr}ì—ì„œ '{query}'ì„(ë¥¼) ê²€ìƒ‰í•©ë‹ˆë‹¤."
                else:
                    response_text = f"{platform_kr} ê²€ìƒ‰ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

            elif action_type == 'platform_translate_search':
                platform = plan['platform']
                query = plan['query']
                lang_ko = plan['lang_ko']
                platform_kr = plan['platform_kr']
                
                lang_map = {'ì˜ì–´': 'English', 'ì¼ë³¸ì–´': 'Japanese', 'ì¤‘êµ­ì–´': 'Chinese'}
                lang_en = lang_map[lang_ko]
                
                if self.CONFIG.get("SHOW_SYSTEM_MESSAGES", False):
                    self.add_message("ì•Œí”„ë ˆë“œ", f"'{query}'ë¥¼ {lang_ko}ë¡œ ë²ˆì—­í•˜ì—¬ {platform_kr}ì—ì„œ ê²€ìƒ‰í•©ë‹ˆë‹¤...", "status_tag")
                
                # ë²ˆì—­ ìˆ˜í–‰ (êµ¬ê¸€ ë²ˆì—­ API ì‚¬ìš©)
                try:
                    params = {
                        'q': query,
                        'source': 'ko',
                        'target': lang_en.lower(),
                        'format': 'text'
                    }
                    response = requests.post('https://translation.googleapis.com/language/translate/v2', params=params, timeout=5)
                    translated_query = response.json()['data']['translations'][0]['translatedText']
                except Exception as e:
                    logger.error(f"ë²ˆì—­ ì‹¤íŒ¨: {e}, API ëŒ€ì²´")
                    # ì‹¤íŒ¨ ì‹œ AI ë²ˆì—­
                    translated_query = self.ask_ai([
                        {"role": "user", "content": f"'{query}'ë¥¼ {lang_en}ë¡œ ë²ˆì—­í•´ì¤˜. ë²ˆì—­ëœ ê²°ê³¼ë§Œ ë§í•´ì¤˜."}
                    ])
                
                # í”Œë«í¼ URL ìƒì„± ë° ì—´ê¸°
                url_templates = {
                    'coupang': "https://www.coupang.com/np/search?q={query}",
                    'youtube': "https://www.youtube.com/results?search_query={query}",
                    'naver': "https://search.naver.com/search.naver?query={query}",
                    'google': "https://www.google.com/search?q={query}"
                }
                
                if platform in url_templates:
                    encoded_query = urllib.parse.quote(translated_query)
                    url = url_templates[platform].format(query=encoded_query)
                    webbrowser.open(url)
                    response_text = f"ì•Œê² ìŠµë‹ˆë‹¤. {platform_kr}ì—ì„œ '{translated_query}'ì„(ë¥¼) ê²€ìƒ‰í•©ë‹ˆë‹¤."
                else:
                    response_text = f"{platform_kr} ê²€ìƒ‰ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

            elif action_type == 'speak': 
                response_text = plan['text']
            elif action_type == 'chat': 
                response_text = self.ask_ai(plan['messages'])
            elif action_type in ['execute', 'terminate']: 
                response_text = self.execute_command(plan['command_info'])
            elif action_type == 'translate_and_search':
                query, lang_ko, lang_en = plan.get('query'), plan.get('lang_ko'), plan.get('lang_en')
                if self.CONFIG.get("SHOW_SYSTEM_MESSAGES", False):
                    self.add_message("ì•Œí”„ë ˆë“œ", f"'{query}'ë¥¼ {lang_ko}ë¡œ ë²ˆì—­í•˜ì—¬ ê²€ìƒ‰í•©ë‹ˆë‹¤...", "status_tag")
                try:
                    params = {
                        'q': query,
                        'source': 'ko',
                        'target': lang_en.lower(),
                        'format': 'text'
                    }
                    response = requests.post('https://translation.googleapis.com/language/translate/v2', params=params, timeout=5)
                    translated_query = response.json()['data']['translations'][0]['translatedText']
                except Exception as e:
                    logger.error(f"ë²ˆì—­ ì‹¤íŒ¨: {e}, API ëŒ€ì²´")
                    translated_query = self.ask_ai([
                        {"role": "user", "content": f"'{query}'ë¥¼ {lang_en}ë¡œ ë²ˆì—­í•´ì¤˜. ë²ˆì—­ëœ ê²°ê³¼ë§Œ ë§í•´ì¤˜."}
                    ])
                encoded_query = urllib.parse.quote(translated_query)
                webbrowser.open(f"https://www.google.com/search?q={encoded_query}")
                response_text = f"'{translated_query}'(ìœ¼)ë¡œ ê²€ìƒ‰ì„ ì‹¤í–‰í•©ë‹ˆë‹¤."
            
            elif action_type == 'exit':
                response_text = "ì•Œê² ìŠµë‹ˆë‹¤. ì–¸ì œë“ ì§€ ë‹¤ì‹œ ë¶ˆëŸ¬ì£¼ì„¸ìš”."
                self.add_message("ì•Œí”„ë ˆë“œ", response_text, "assistant_tag")
                self.speak(response_text, sync=True)
                self.gui_queue.put({'type': 'exit'})
                return
            
            elif action_type == 'greeting':
                greetings = [
                    f"ì•ˆë…•í•˜ì„¸ìš”, {self.CONFIG.get('USER_NAME', 'ì‚¬ìš©ì')}ë‹˜! ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?",
                    f"ë°˜ê°‘ìŠµë‹ˆë‹¤! ì˜¤ëŠ˜ì€ ì–´ë–¤ ì¼ì„ ë„ì™€ë“œë¦´ê¹Œìš”?",
                    f"ì•ˆë…•í•˜ì„¸ìš”! ê¸°ì˜ê²Œ ë„ì™€ë“œë¦¬ê² ìŠµë‹ˆë‹¤."
                ]
                response_text = np.random.choice(greetings)
            
            elif action_type == 'weather':  # ë‚ ì”¨ ì¡°íšŒ ì²˜ë¦¬
                location = plan.get('location')
                forecast = plan.get('forecast', 'í˜„ì¬')
                
                # ìœ„ì¹˜ê°€ ì§€ì •ë˜ì§€ ì•Šì•˜ìœ¼ë©´ í”„ë¡œí•„ì—ì„œ ê°€ì ¸ì˜¤ê¸°
                if not location:
                    location = self.user_profile.profile["personal_facts"].get("ê±°ì£¼ì§€", "ì„œìš¸")  # ê¸°ë³¸ê°’ ì„œìš¸
                
                # ìœ„ì¹˜ì—ì„œ íŠ¹ë³„ì‹œ/ê´‘ì—­ì‹œë§Œ ì¶”ì¶œ (ì˜ˆ: "ì„œìš¸ ê°•ë‚¨êµ¬" -> "ì„œìš¸")
                if ' ' in location:
                    city = location.split()[0]
                    # ì£¼ìš” ê´‘ì—­ì‹œ ëª©ë¡
                    metropolitan_cities = ['ì„œìš¸', 'ë¶€ì‚°', 'ëŒ€êµ¬', 'ì¸ì²œ', 'ê´‘ì£¼', 'ëŒ€ì „', 'ìš¸ì‚°']
                    if city in metropolitan_cities:
                        location = city
                
                # ë‚ ì”¨ API í˜¸ì¶œ
                try:
                    api_key = self.CONFIG.get("WEATHER_API_KEY")
                    if not api_key:
                        response_text = "âš ï¸ ë‚ ì”¨ API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. config.json íŒŒì¼ì„ í™•ì¸í•´ì£¼ì„¸ìš”."
                    else:
                        # ìœ„ì¹˜ ì •ë³´ URL ì¸ì½”ë”©
                        encoded_location = urllib.parse.quote(location)
                        
                        # í˜„ì¬ ë‚ ì”¨ API í˜¸ì¶œ (OpenWeatherMap)
                        if forecast in ['í˜„ì¬', 'ì˜¤ëŠ˜']:
                            url = f"https://api.openweathermap.org/data/2.5/weather?q={encoded_location}&appid={api_key}&units=metric&lang=kr"
                            response = requests.get(url, timeout=5)
                            data = response.json()
                            
                            if response.status_code == 200:
                                temp = data['main']['temp']
                                desc = data['weather'][0]['description']
                                humidity = data['main']['humidity']
                                response_text = f"ğŸŒ¤ï¸ {location}ì˜ í˜„ì¬ ë‚ ì”¨: {desc}, ì˜¨ë„: {temp}Â°C, ìŠµë„: {humidity}%"
                            else:
                                # ê°„ì†Œí™”ëœ ì˜¤ë¥˜ ë©”ì‹œì§€
                                response_text = f"âš ï¸ {location}ì˜ ë‚ ì”¨ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤"
                                
                        # ë‚´ì¼/ëª¨ë ˆ ë‚ ì”¨ (ê¸°ìƒì²­ ë‹¨ê¸°ì˜ˆë³´ í™œìš©)
                        elif forecast in ['ë‚´ì¼', 'ëª¨ë ˆ']:
                            # ê°„ì†Œí™”ëœ ì‘ë‹µ (ì‹¤ì œ ì„œë¹„ìŠ¤ì—ì„œëŠ” API êµ¬í˜„ í•„ìš”)
                            response_text = f"â›… {location}ì˜ {forecast} ë‚ ì”¨: ê°„í¸ ì •ë³´ ì„œë¹„ìŠ¤ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤"
                            
                except Exception as e:
                    logger.error(f"ë‚ ì”¨ API ì˜¤ë¥˜: {str(e)}")
                    response_text = f"âš ï¸ {location} ë‚ ì”¨ ì •ë³´ ìš”ì²­ ì‹¤íŒ¨: {str(e)}"
            
            if response_text:
                self.add_message("ì•Œí”„ë ˆë“œ", response_text, "assistant_tag")
                self.speak(response_text)
                
                # ëŒ€í™” ê¸°ë¡ ì €ì¥
                if not is_internal:
                    self.conversation_history.append({"role": "assistant", "content": response_text})
                
                # ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œì— ì €ì¥
                if not is_internal:
                    try:
                        self.memory_model.add_document(command)
                        self.memory_model.add_document(response_text)
                    except Exception as e:
                        logger.error(f"ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œ ì €ì¥ ì˜¤ë¥˜: {e}")
                
                # ì‚¬ìš©ì ì •ë³´ ì¶”ì¶œ ë° ì—…ë°ì´íŠ¸ (í‚¤ì›Œë“œ ê¸°ë°˜)
                if not is_internal and any(keyword in command for keyword in ["ê¸°ì–µí•´", "ì €ì¥í•´", "ì•Œì•„ë‘¬"]):
                    new_facts = self.extract_user_facts(command, response_text)
                    if new_facts and any(new_facts.values()):
                        self.user_profile.update_profile(new_facts)
                        if self.CONFIG.get("SHOW_SYSTEM_MESSAGES", False):
                            self.add_message("í”„ë¡œí•„ ì‹œìŠ¤í…œ", "ì‚¬ìš©ì ì •ë³´ê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤", "memory_tag")
                
                # ë©”ëª¨ë¦¬ ê´€ë¦¬: ìµœëŒ€ 100ê°œ ëŒ€í™” ìœ ì§€
                if len(self.conversation_history) > 100:
                    self.conversation_history = self.conversation_history[-100:]
                    
                # 10ê°œë§ˆë‹¤ ìë™ ì €ì¥ (ë°ì´í„° ì†ì‹¤ ë°©ì§€)
                if len(self.conversation_history) % 10 == 0:
                    threading.Thread(target=self.save_memory, daemon=True).start()
        
        finally:
            # ìŠ¤ë ˆë“œ ì¶”ì  ì œê±°
            if tid in self.active_threads:
                del self.active_threads[tid]

    def close_app(self):
        """ì•± ì¢…ë£Œ ì²˜ë¦¬ - ë©”ëª¨ë¦¬ ì €ì¥ í›„ ì•ˆì „í•˜ê²Œ ì¢…ë£Œ"""
        logger.info("\n=== ì• í”Œë¦¬ì¼€ì´ì…˜ ì¢…ë£Œ ì‹œì‘ ===")
        
        # ë©”ëª¨ë¦¬ ì €ì¥ (ë™ê¸°ì‹ìœ¼ë¡œ ì™„ë£Œ ë³´ì¥)
        self.save_memory()
        
        # ì‚¬ìš©ì í”„ë¡œí•„ ì €ì¥
        self.user_profile.save_profile()
        
        # ì‹¤í–‰ í”Œë˜ê·¸ ë³€ê²½
        self.running = False
        
        # ìŒì„± ì¶œë ¥ ì¤‘ì§€
        pygame.mixer.music.stop()
        
        # GUI ì¢…ë£Œ
        self.destroy()
        
        # Pygame ì¢…ë£Œ
        pygame.mixer.quit()
        logger.info("=== ì•ˆì „í•˜ê²Œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤ ===")

    def send_command(self, event=None):
        command = self.input_field.get().strip()
        if command:
            self.add_message(f"{self.CONFIG.get('USER_NAME', 'ì‚¬ìš©ì')}", command, "user_tag")
            self.input_field.delete(0, tk.END)
            threading.Thread(target=self.process_command, args=(command,), daemon=True).start()

    def speak(self, text, sync=False):
        if not text: return
        text = re.sub(r'\*\*', '', text)
        logger.info(f"ğŸ”Š ì•Œí”„ë ˆë“œ: {text}")
        self.is_speaking.set()
        def tts_task():
            try: asyncio.run(self._speak_async(text))
            finally: 
                self.is_speaking.clear()
                if self.is_listening and self.CONFIG.get("SHOW_SYSTEM_MESSAGES", False):
                    self.gui_queue.put({'type': 'update_voice_button', 'text': "ğŸ¤...", 'bg': "#FFC107"})
                    self.gui_queue.put({'type': 'add_message', 'sender': 'ì‹œìŠ¤í…œ', 'text': 'ë“£ê³  ìˆìŠµë‹ˆë‹¤...', 'tag': 'status_tag'})
        tts_thread = threading.Thread(target=tts_task, daemon=True)
        tts_thread.start()
        if sync: tts_thread.join()

    async def _speak_async(self, text):
        try:
            communicate = edge_tts.Communicate(text, self.VOICE, rate=self.RATE)
            audio_bytes = b""
            async for chunk in communicate.stream():
                if chunk["type"] == "audio": audio_bytes += chunk["data"]
            if not audio_bytes: return
            
            # Pygame ë²„í¼ ë¬¸ì œ í•´ê²°
            with io.BytesIO() as audio_stream:
                audio_stream.write(audio_bytes)
                audio_stream.seek(0)
                try:
                    pygame.mixer.music.load(audio_stream)
                    pygame.mixer.music.play()
                    while pygame.mixer.music.get_busy(): 
                        await asyncio.sleep(0.1)
                except pygame.error as e:
                    logger.error(f"Pygame ìŒì„± ì¬ìƒ ì˜¤ë¥˜: {e}")
        except Exception as e: 
            logger.error(f"ë¹„ë™ê¸° ìŒì„± ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")

    def ask_ai(self, messages):
        try:
            # ì¼ë°˜ ì‘ë‹µ ë°©ì‹ìœ¼ë¡œ ë³€ê²½ (ìŠ¤íŠ¸ë¦¬ë° ì œê±°)
            response = self.client.chat.completions.create(
                model=self.CONFIG["DEEPSEEK_MODEL"],
                messages=messages,
                timeout=10,  # íƒ€ì„ì•„ì›ƒ ë‹¨ì¶•
                max_tokens=500
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            logger.error(f"AI API í†µì‹  ì˜¤ë¥˜: {e}")
            return "âš ï¸ ì‘ë‹µ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”."

    def execute_command(self, command_info):
        cmd = command_info.get(platform.system().lower(), command_info.get("windows"))
        if cmd:
            try:
                if isinstance(cmd, list): subprocess.Popen(cmd)
                else: subprocess.Popen(cmd, shell=True)
                return self.get_response_text(command_info)
            except Exception as e: return f"ëª…ë ¹ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜: {e}"
        return "ì´ ìš´ì˜ì²´ì œì—ì„œëŠ” ì§€ì›ë˜ì§€ ì•ŠëŠ” ëª…ë ¹ì–´ì…ë‹ˆë‹¤."

    def get_response_text(self, command_info):
        target = command_info.get('target_name', '')
        action_type = command_info.get('action_type')
        verb_map = {
            'execute': 'ì‹¤í–‰í•˜ê² ìŠµë‹ˆë‹¤', 'terminate': 'ì¢…ë£Œí•˜ê² ìŠµë‹ˆë‹¤',
            'open_file': 'ì—´ê² ìŠµë‹ˆë‹¤', 'empty': 'ë¹„ìš°ê² ìŠµë‹ˆë‹¤'
        }
        action_verb = verb_map.get(action_type, 'ìˆ˜í–‰í•˜ê² ìŠµë‹ˆë‹¤')
        if not target: return f"ì•Œê² ìŠµë‹ˆë‹¤. ìš”ì²­í•˜ì‹  ì‘ì—…ì„ {action_verb}."
        last_char = target[-1]
        josa = "ì„" if 'ê°€' <= last_char <= 'í£' and (ord(last_char) - ord('ê°€')) % 28 > 0 else "ë¥¼"
        return f"ì•Œê² ìŠµë‹ˆë‹¤. {target}{josa} {action_verb}."
    
    def stop_speech(self):
        pygame.mixer.music.stop()
        self.is_speaking.clear()
        if self.CONFIG.get("SHOW_SYSTEM_MESSAGES", False):
            self.add_message("ì‹œìŠ¤í…œ", "ìŒì„± ì¶œë ¥ì„ ì¤‘ë‹¨í–ˆìŠµë‹ˆë‹¤.", "status_tag")

    def initial_greeting(self):
        # ì§ì ‘ ì¸ì‚¬ë§ ìƒì„±í•˜ì—¬ ì¶œë ¥ (process_command ê±°ì¹˜ì§€ ì•ŠìŒ)
        greetings = [
            f"ì•ˆë…•í•˜ì„¸ìš”, {self.CONFIG.get('USER_NAME', 'ì‚¬ìš©ì')}ë‹˜! ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?",
            f"ë°˜ê°‘ìŠµë‹ˆë‹¤! ì˜¤ëŠ˜ì€ ì–´ë–¤ ì¼ì„ ë„ì™€ë“œë¦´ê¹Œìš”?",
            f"ì•ˆë…•í•˜ì„¸ìš”! ê¸°ì˜ê²Œ ë„ì™€ë“œë¦¬ê² ìŠµë‹ˆë‹¤."
        ]
        response_text = np.random.choice(greetings)
        self.add_message("ì•Œí”„ë ˆë“œ", response_text, "assistant_tag")
        self.speak(response_text)

    def add_message(self, sender, message, tag):
        self.gui_queue.put({'type': 'add_message', 'sender': sender, 'text': message, 'tag': tag})
        
    def _add_message_from_queue(self, sender, message, tag):
        self.output_area.config(state=tk.NORMAL)
        self.output_area.insert(tk.END, f"{sender}: ", tag)
        self.output_area.insert(tk.END, f"{message}\n\n")
        self.output_area.config(state=tk.DISABLED)
        self.output_area.see(tk.END)

    def check_gui_queue(self):
        try:
            while True:
                task = self.gui_queue.get_nowait()
                if task['type'] == 'add_message':
                    self._add_message_from_queue(task['sender'], task['text'], task['tag'])
                elif task['type'] == 'update_voice_button':
                    self.voice_button.config(text=task['text'], bg=task['bg'])
                elif task['type'] == 'exit':
                    self.close_app()
        except queue.Empty: pass
        finally:
            if self.running: self.after(100, self.check_gui_queue)

    def toggle_voice_input(self):
        self.is_listening = not self.is_listening
        if self.is_listening:
            self.gui_queue.put({'type': 'update_voice_button', 'text': "ğŸ¤...", 'bg': "#FFC107"})
            if self.CONFIG.get("SHOW_SYSTEM_MESSAGES", False):
                self.add_message("ì‹œìŠ¤í…œ", "ë“£ê³  ìˆìŠµë‹ˆë‹¤...", "status_tag")
        else:
            self.gui_queue.put({'type': 'update_voice_button', 'text': "ğŸ¤", 'bg': "#4CAF50"})
            if self.CONFIG.get("SHOW_SYSTEM_MESSAGES", False):
                self.add_message("ì‹œìŠ¤í…œ", "ìŒì„± ì¸ì‹ì„ ì¤‘ë‹¨í–ˆìŠµë‹ˆë‹¤.", "status_tag")
    
    def voice_input_worker(self):
        r = sr.Recognizer()
        r.energy_threshold = 4000
        r.dynamic_energy_threshold = True
        r.dynamic_energy_adjustment_damping = 0.15
        r.dynamic_energy_ratio = 1.5
        r.pause_threshold = 1.0  # ê°ì§€ ëŒ€ê¸° ì‹œê°„ ë‹¨ì¶•
        
        while self.running:
            if not self.is_listening or self.is_speaking.is_set():
                time.sleep(0.1)
                continue
            
            try:
                with sr.Microphone() as source:
                    logger.info("ìŒì„± ì¸ì‹ì„ ìœ„í•´ ë§ˆì´í¬ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤...")
                    r.adjust_for_ambient_noise(source, duration=0.5)
                    logger.info(f"ìŒì„± ì¸ì‹ ëŒ€ê¸° ì¤‘... ì—ë„ˆì§€ ì„ê³„ê°’: {r.energy_threshold:.2f}")
                    
                    try:
                        audio = r.listen(source, timeout=3, phrase_time_limit=5)
                    except sr.WaitTimeoutError:
                        continue
                    
                    try:
                        # ì˜¤í”„ë¼ì¸ ìŒì„± ì¸ì‹ (Vosk) ì‚¬ìš©
                        text = r.recognize_google(audio, language='ko-KR').strip()
                        text = re.sub(r'\b(ìŒ|ìŒìŒ|ìŒ\.)\b', '', text).strip()
                        
                        if text:
                            self.add_message(f"{self.CONFIG.get('USER_NAME', 'ì‚¬ìš©ì')}", text, "user_tag")
                            threading.Thread(target=self.process_command, args=(text,), daemon=True).start()
                    except sr.UnknownValueError:
                        if self.CONFIG.get("SHOW_SYSTEM_MESSAGES", False):
                            self.add_message("ì‹œìŠ¤í…œ", "ìŒì„±ì„ ì¸ì‹í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤", "status_tag")
                    except sr.RequestError as e:
                        logger.error(f"ìŒì„± ì¸ì‹ ì„œë¹„ìŠ¤ ì˜¤ë¥˜: {e}")
                        self.gui_queue.put({'type': 'add_message', 'sender': 'ì‹œìŠ¤í…œ', 'text': f'ìŒì„± ì„œë¹„ìŠ¤ ì˜¤ë¥˜: {e}', 'tag': 'status_tag'})
                        time.sleep(2)
                    
            except OSError as e:
                logger.error(f"ë§ˆì´í¬ ì˜¤ë¥˜: {e}, ì¬ì‹œë„ ì¤‘...")
                time.sleep(3)  # ì˜¤ë¥˜ ì‹œ ê¸´ ëŒ€ê¸° ì‹œê°„
            except Exception as e:
                logger.error(f"ìŒì„± ì¸ì‹ ë£¨í”„ ì˜¤ë¥˜: {e}")
                self.is_listening = False
                self.gui_queue.put({'type': 'update_voice_button', 'text': "ğŸ¤", 'bg': "#4CAF50"})
                time.sleep(5)  # ì‹¬ê°í•œ ì˜¤ë¥˜ ì‹œ ê¸´ ëŒ€ê¸°

    def monitor_active_tab(self):
        if not pythoncom or platform.system() != 'Windows': 
            return
            
        pythoncom.CoInitialize()
        chrome_control = auto.Control(ClassName='Chrome_WidgetWin_1')
        
        while self.running:
            try:
                time.sleep(1)
                hwnd = win32gui.GetForegroundWindow()
                window_title = win32gui.GetWindowText(hwnd)
                url = None
                
                if "Chrome" in window_title or "Edge" in window_title:
                    try:
                        pane = chrome_control.PaneControl(Name=window_title)
                        address_bar = pane.EditControl(Name="ì£¼ì†Œ ë° ê²€ìƒ‰ì°½")
                        
                        if not address_bar.Exists(0.5, 0.5):
                            address_bar = pane.EditControl(Name="Address and search bar")
                        
                        if address_bar.Exists(0.5, 0.5):
                            url = address_bar.GetValuePattern().Value
                    except Exception:
                        continue
                else: 
                    continue
                    
                if url:
                    with self.context_lock:
                        self.conversation_context["active_tab"] = {
                            "title": window_title, 
                            "url": url
                        }
            except Exception as e:
                logger.error(f"íƒ­ ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜: {e}")
                
        pythoncom.CoUninitialize()

if __name__ == "__main__":
    try:
        app = App()
        app.mainloop()
    except Exception as e:
        logger.critical(f"ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰ ì¤‘ ì‹¬ê°í•œ ì˜¤ë¥˜ ë°œìƒ: {e}")
    finally:
        sys.exit(0)

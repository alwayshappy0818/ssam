#include <Arduino.h>
#include <Servo.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// ====================================================
// 1. 핀 설정 (최종 하드웨어 배선)
// ====================================================

// [LED]
const int LED_EYE = 2; // 왼쪽 눈 (제어 가능)
// 오른쪽 전원등(3.3V)은 상시 점등

// [OLED 디스플레이]
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET    -1 
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// [DC 모터 & 릴레이]
const int PIN_RELAY = 12;
// STBY는 5V 직결
const int PWMA = 5; const int AIN1 = 3; const int AIN2 = 4; // Left
const int PWMB = 6; const int BIN1 = 7; const int BIN2 = 8; // Right

// [서보 모터]
const int PIN_HEAD_PAN  = 9;  
const int PIN_HEAD_TILT = 10; 
const int PIN_ARM_L     = 11; 
const int PIN_ARM_R     = A0; 

// 객체 생성
Servo headPan, headTilt, armL, armR;
const int MAX_PWM_LIMIT = 255; 

// 서보 설정
const int SERVO_DELAY = 15; 

// 통신 버퍼
const byte numChars = 64;
char receivedChars[numChars];
boolean newData = false;

// [심심함 모드 변수]
unsigned long lastCommandTime = 0;       // 마지막 명령 수신 시간
const unsigned long IDLE_TIMEOUT = 5000; // 5초간 조용하면 딴짓 시작
bool isSystemReady = false;              // 파이썬 준비 완료 여부

// 함수 선언
void controlDrive(int left, int right);
void setMotor(int motorIdx, int speed);
void controlRelay(int state);
void controlServos(int p, int t, int l, int r);
void controlEye(int state);
void updateOLED(String text, int size = 2);
void blinkEye(); 
void recvWithStartEndMarkers();
void parseData();
void performDance(); 
void idleMotion();   

void setup() {
  Serial.begin(115200); 

  // 핀 모드 설정
  pinMode(LED_EYE, OUTPUT); 
  pinMode(PIN_RELAY, OUTPUT); 
  pinMode(PWMA, OUTPUT); pinMode(AIN1, OUTPUT); pinMode(AIN2, OUTPUT);
  pinMode(PWMB, OUTPUT); pinMode(BIN1, OUTPUT); pinMode(BIN2, OUTPUT);

  // 서보 초기화
  headPan.attach(PIN_HEAD_PAN); headTilt.attach(PIN_HEAD_TILT);
  armL.attach(PIN_ARM_L);     armR.attach(PIN_ARM_R);
  
  // 대기 자세 (고개 숙임)
  headPan.write(90); headTilt.write(60);
  armL.write(0);     armR.write(0);

  // OLED 초기화
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { 
    for(;;); 
  }
  display.clearDisplay();
  
  // 부팅 중 상태 (전원 차단)
  digitalWrite(PIN_RELAY, LOW); 
  controlEye(0); 
  updateOLED("SYSTEM\nBOOTING...");
}

void loop() {
  recvWithStartEndMarkers();
  
  if (newData == true) {
    parseData();
    newData = false;
    lastCommandTime = millis(); // 명령 받으면 타이머 리셋
  }

  // [심심함 모드 로직]
  // 시스템이 켜져 있고(Ready), 5초 이상 명령이 없으면 실행
  if (isSystemReady && (millis() - lastCommandTime > IDLE_TIMEOUT)) {
    idleMotion();
  }
}

// --- 로직 함수 ---

// [심심함 모드] 3초마다 랜덤 행동
void idleMotion() {
  static unsigned long lastIdleMove = 0;
  
  if (millis() - lastIdleMove > 3000) {
    int action = random(0, 4); // 0~3 랜덤 선택
    
    if (action == 0) { 
        // 고개 갸웃거리기
        updateOLED("STATUS:\nIDLE...", 1);
        headPan.write(random(70, 110));
        headTilt.write(random(80, 100));
    } else if (action == 1) { 
        // 팔 꼼지락
        armL.write(random(0, 30));
        armR.write(random(0, 30));
    } else if (action == 2) {
        // 눈 깜빡
        blinkEye();
    }
    // action 3은 아무것도 안 하고 멍때리기
    
    lastIdleMove = millis();
  }
}

// [댄스 모드]
void performDance() {
  updateOLED("MODE:\nDANCE!");
  lastCommandTime = millis(); // 댄스 중 Idle 진입 방지
  
  for(int i=0; i<2; i++) {
    controlServos(60, 110, 150, 0); 
    controlDrive(-150, 150); 
    blinkEye();
    delay(400);
    
    controlServos(120, 70, 0, 150);
    controlDrive(150, -150); 
    blinkEye();
    delay(400);
  }
  
  controlDrive(0, 0);
  controlServos(90, 90, 0, 0); 
  controlEye(1); 
  updateOLED("WALL-E\nONLINE");
}

void updateOLED(String text, int size) {
  display.clearDisplay();
  display.setTextSize(size);      
  display.setTextColor(SSD1306_WHITE); 
  display.setCursor(0,0);     
  display.println(text);
  display.display();
}

void blinkEye() {
  digitalWrite(LED_EYE, LOW);
  delay(150);
  digitalWrite(LED_EYE, HIGH);
}

void controlEye(int state) {
  if (state == 1) digitalWrite(LED_EYE, HIGH);
  else digitalWrite(LED_EYE, LOW);
}

void controlServos(int p, int t, int l, int r) {
  if(p != -1) headPan.write(constrain(p, 0, 180));
  if(t != -1) headTilt.write(constrain(t, 0, 180));
  if(l != -1) armL.write(constrain(l, 0, 180));
  if(r != -1) armR.write(constrain(r, 0, 180));
  delay(SERVO_DELAY);
}

void controlRelay(int state) {
  if (state == 1) {
    digitalWrite(PIN_RELAY, HIGH);
  } else {
    digitalWrite(PIN_RELAY, LOW);
    controlDrive(0, 0); 
    controlEye(0); 
    updateOLED("POWER OFF");
    isSystemReady = false; 
  }
}

void controlDrive(int leftSpeed, int rightSpeed) {
  setMotor(1, leftSpeed);
  setMotor(2, rightSpeed);
}

void setMotor(int motorIdx, int inputSpeed) {
  int pinPWM, pinIN1, pinIN2;
  if (motorIdx == 1) { pinPWM = PWMA; pinIN1 = AIN1; pinIN2 = AIN2; }
  else               { pinPWM = PWMB; pinIN1 = BIN1; pinIN2 = BIN2; }

  inputSpeed = constrain(inputSpeed, -255, 255);
  
  if (inputSpeed > 0) {
    digitalWrite(pinIN1, HIGH); digitalWrite(pinIN2, LOW);
    analogWrite(pinPWM, inputSpeed);
  } else if (inputSpeed < 0) {
    digitalWrite(pinIN1, LOW); digitalWrite(pinIN2, HIGH);
    analogWrite(pinPWM, -inputSpeed);
  } else {
    digitalWrite(pinIN1, LOW); digitalWrite(pinIN2, LOW);
    analogWrite(pinPWM, 0);
  }
}

void recvWithStartEndMarkers() {
  static boolean recvInProgress = false;
  static byte ndx = 0;
  char startMarker = '<';
  char endMarker = '>';
  char rc;
  while (Serial.available() > 0 && newData == false) {
    rc = Serial.read();
    if (recvInProgress == true) {
      if (rc != endMarker) {
        receivedChars[ndx] = rc;
        ndx++;
        if (ndx >= numChars) ndx = numChars - 1;
      } else {
        receivedChars[ndx] = '\0';
        recvInProgress = false;
        ndx = 0;
        newData = true;
      }
    } else if (rc == startMarker) recvInProgress = true;
  }
}

void parseData() {
  char *strtokIndx;
  strtokIndx = strtok(receivedChars, ",");
  String cmd = String(strtokIndx);
  cmd.trim(); 
  
  strtokIndx = strtok(NULL, ",");
  int val1 = (strtokIndx != NULL) ? atoi(strtokIndx) : 0;
  
  strtokIndx = strtok(NULL, ",");
  int val2 = (strtokIndx != NULL) ? atoi(strtokIndx) : 0;

  if (cmd == "READY") {
    isSystemReady = true;
    digitalWrite(PIN_RELAY, HIGH); 
    controlEye(1);                 
    headTilt.write(90); // 고개 들기
    updateOLED("WALL-E\nONLINE");
    return;
  }

  if (cmd == "ERROR") {
    updateOLED("VOICE\nFAIL!");
    blinkEye();
    return;
  }

  if (cmd == "MOVE") {
    updateOLED("ACTION:\nMOVING");
    controlDrive(val1, val2);
  } 
  else if (cmd == "HEAD") controlServos(val1, val2, -1, -1);
  else if (cmd == "ARM") controlServos(-1, -1, val1, val2);
  else if (cmd == "RELAY") controlRelay(val1);
  else if (cmd == "DANCE") performDance();
  else if (cmd == "EYE") controlEye(val1);
  else if (cmd == "STOP") {
    controlDrive(0, 0);
    updateOLED("WALL-E\nSTOPPED");
  }
}

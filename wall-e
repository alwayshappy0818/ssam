import os
import sys
import json
import asyncio
import queue
import threading
import time
import re

try:
    import speech_recognition as sr
    import edge_tts
    import pygame
    from openai import OpenAI, APIStatusError
except ImportError:
    print("오류: 필수 라이브러리가 설치되지 않았습니다.")
    print("터미널에 'pip install openai speechrecognition edge-tts pygame pyaudio'를 실행하여 설치해주세요.")
    sys.exit(1)

OPENROUTER_API_KEY = "API여기다가 입력"

# 사용하려는 마이크가 기본 마이크가 아닐 경우, 아래 목록에서 확인 후 숫자를 변경하세요.
# 사용 가능한 마이크 목록은 코드를 처음 실행할 때 터미널에 출력됩니다.
# 예: MICROPHONE_INDEX = 1
MICROPHONE_INDEX = None

CONVERSATION_HISTORY = []

# --- 메인 애플리케이션 클래스 ---
class ConversationalAI:
    def __init__(self, api_key):
        """초기화 메서드"""
        self.api_key = api_key
        self.running = True
        self.is_speaking = threading.Event()

        # OpenAI 클라이언트 초기화 (OpenRouter 사용)
        self.llm_client = OpenAI(
            api_key=self.api_key,
            base_url="https://openrouter.ai/api/v1",
            default_headers={
                "HTTP-Referer": "http://localhost",
                "X-Title": "Conversational AI",
            },
        )

        self.tts_queue = queue.Queue()
        self.tts_thread = threading.Thread(target=self._tts_worker, daemon=True)

        self.recognizer = sr.Recognizer()
        self.microphone = sr.Microphone(device_index=MICROPHONE_INDEX if MICROPHONE_INDEX is not None else None)

        # 오디오 재생 초기화
        try:
            pygame.mixer.pre_init(44100, -16, 2, 512)
            pygame.mixer.init()
        except pygame.error as e:
            print(f"Pygame 믹서 초기화 오류: {e}")
            print("오디오 장치가 연결되어 있는지, 드라이버가 올바르게 설치되었는지 확인하세요.")
            sys.exit(1)


    def _tts_worker(self):
        """TTS 요청을 순차적으로 처리하는 백그라운드 스레드"""
        asyncio.run(self._tts_worker_async())

    async def _tts_worker_async(self):
        """TTS 비동기 작업자 (파일 저장 및 재생 방식)"""
        while self.running:
            try:
                text_to_speak = self.tts_queue.get(timeout=1)
                if text_to_speak is None: break
                self.is_speaking.set()

                print(f"🤖 AI: {text_to_speak}")

                communicate = edge_tts.Communicate(text_to_speak, "ko-KR-SunHiNeural")
                with open("response.mp3", "wb") as file:
                    async for chunk in communicate.stream():
                        if chunk["type"] == "audio":
                            file.write(chunk["data"])

                pygame.mixer.music.load("response.mp3")
                pygame.mixer.music.play()
                while pygame.mixer.music.get_busy():
                    await asyncio.sleep(0.1)
                
                pygame.mixer.music.unload()
                await asyncio.sleep(0.1)

                try:
                    os.remove("response.mp3")
                except (PermissionError, OSError) as e:
                    print(f"경고: 임시 오디오 파일('response.mp3')을 삭제하지 못했습니다: {e}")

                self.is_speaking.clear()
                self.tts_queue.task_done()

            except queue.Empty:
                continue
            except Exception as e:
                print(f"TTS 작업 중 오류 발생: {e}")
                self.is_speaking.clear()
                try:
                    pygame.mixer.music.unload()
                    if os.path.exists("response.mp3"):
                        os.remove("response.mp3")
                except Exception:
                    pass


    def speak(self, text):
        """말할 텍스트를 TTS 큐에 추가"""
        if self.running:
            self.tts_queue.put(text)

    def listen_and_process(self):
        """사용자의 음성을 듣고 전체 대화 과정을 처리"""
        try:
            mic_idx_str = str(MICROPHONE_INDEX) or "기본 마이크"
            print(f"마이크 '{mic_idx_str}'를 열고 있습니다...")
            with self.microphone as source:
                print("주변 소음 분석 중... (잠시만 기다려주세요)")
                self.recognizer.adjust_for_ambient_noise(source, duration=1)
                print(f"소음 분석 완료. (에너지 임계값: {self.recognizer.energy_threshold:.2f})")
        except Exception as e:
            mic_idx_str = str(MICROPHONE_INDEX) or "기본 마이크"
            print(f"마이크 '{mic_idx_str}'를 열 수 없습니다: {e}")
            self.running = False
            return

        while self.running:
            if self.is_speaking.is_set():
                time.sleep(0.1)
                continue

            try:
                with self.microphone as source:
                    print("\n🎤 듣고 있습니다...")
                    audio = self.recognizer.listen(source, timeout=5, phrase_time_limit=10)

                print("...생각 중...")
                user_text = self.recognizer.recognize_google(audio, language="ko-KR")
                print(f"👤 사용자: {user_text}")

                CONVERSATION_HISTORY.append({"role": "user", "text": user_text})

                if any(keyword in user_text for keyword in ["종료"]):
                    self.speak("알겠습니다. 좋은 하루 보내세요.")
                    self.tts_queue.join()
                    self.stop()
                    break

                ai_response = self.ask_ai()
                CONVERSATION_HISTORY.append({"role": "assistant", "content": ai_response})
                self.speak(ai_response)
                
                self.tts_queue.join()

            except sr.WaitTimeoutError:
                continue
            except sr.UnknownValueError:
                print("죄송합니다, 이해하지 못했어요. 다시 말씀해주시겠어요?")
                continue
            except sr.RequestError as e:
                print(f"음성 인식 서비스에 접근할 수 없습니다: {e}")
                self.stop()

    def ask_ai(self):
        """LLM API를 호출하여 답변을 생성"""
        if not CONVERSATION_HISTORY:
            return "무엇을 도와드릴까요?"

        system_prompt = {
            "role": "system",
            "content": "핵심만 간결하게 3~5문장 이내로 답변."
        }
        messages = [system_prompt] + CONVERSATION_HISTORY[-10:]

        try:
            response = self.llm_client.chat.completions.create(
                model="deepseek/deepseek-chat-v3.1:free:nitro",
                messages=messages,
                stream=False
            )
            raw_content = response.choices[0].message.content
            cleaned_content = re.sub(r'<think>.*?</think>', '', raw_content, flags=re.DOTALL)
            cleaned_content = cleaned_content.strip()
            return cleaned_content
        except APIStatusError as e:
            print(f"LLM API 상태 오류 발생: {e.status_code} - {e.response}")
            if e.status_code == 401:
                return "API 키 인증에 실패했습니다. 코드 상단의 API 키를 확인해주세요."
            elif e.status_code == 429:
                return "API 하루 사용량을 초과했거나 요청이 너무 많습니다. 잠시 후 다시 시도해주세요."
            else:
                return f"API 서버에서 오류가 발생했습니다. (코드: {e.status_code})"
        except Exception as e:
            print(f"LLM API 호출 중 예기치 않은 오류 발생: {e}")
            return "죄송합니다. 답변을 생성하는 중에 문제가 발생했습니다."

    def start(self):
        """대화형 AI 시작"""
        self.tts_thread.start()
        self.speak("안녕하세요, 무엇을 도와드릴까요?")
        self.listen_and_process()

    def stop(self):
        """애플리케이션 종료"""
        if self.running:
            self.running = False
            self.tts_queue.put(None)
            print("\n프로그램을 종료합니다...")

def keyboard_listener(ai_instance):
    """'q' 입력 시 종료하는 리스너"""
    while ai_instance.running:
        try:
            if sys.stdin.isatty():
                inp = input()
                if inp.lower() == 'q':
                    print("'q' 입력이 감지되었습니다. 프로그램을 종료합니다.")
                    ai_instance.stop()
                    break
        except (EOFError, KeyboardInterrupt):
            break
        except Exception:
            time.sleep(1)

def check_microphones():
    """시스템에 연결된 마이크 목록을 출력하는 함수"""
    print("--- 사용 가능한 마이크 목록 ---")
    try:
        mic_list = sr.Microphone.list_microphone_names()
        if not mic_list:
            print("사용 가능한 마이크를 찾을 수 없습니다.")
            return False
        
        for index, name in enumerate(mic_list):
            print(f"  마이크 {index}: {name}")
        print("---------------------------------")
        print("기본 마이크가 아닌 다른 마이크를 사용하려면, 코드 상단의 'MICROPHONE_INDEX' 값을 해당 마이크의 번호로 변경하세요.")
        return True
    except Exception as e:
        print(f"마이크 목록을 가져오는 중 오류 발생: {e}")
        return False

def main():
    """메인 실행 함수"""
    if not check_microphones():
        return

    if not OPENROUTER_API_KEY or OPENROUTER_API_KEY == "YOUR_API_KEY_HERE":
        print("\n[오류] API 키가 설정되지 않았습니다.")
        print("코드 상단의 'OPENROUTER_API_KEY' 변수에 유효한 키를 입력하세요.")
        return

    ai = ConversationalAI(OPENROUTER_API_KEY)

    input_thread = threading.Thread(target=keyboard_listener, args=(ai,), daemon=True)
    input_thread.start()
    print("\n프로그램을 종료하려면 'q'를 입력하고 Enter 키를 누르세요.")

    try:
        ai.start()
    except KeyboardInterrupt:
        ai.stop()
    finally:
        pygame.mixer.quit()
        if os.path.exists("response.mp3"):
            try:
                os.remove("response.mp3")
            except (PermissionError, OSError) as e:
                print(f"경고: 종료 시 임시 파일을 삭제하지 못했습니다: {e}")


if __name__ == "__main__":
    main()

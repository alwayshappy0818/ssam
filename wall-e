import os
import sys
import json
import asyncio
import queue
import threading
import time
import re

try:
    import speech_recognition as sr
    import edge_tts
    import pygame
    from openai import OpenAI, APIStatusError
except ImportError:
    print("ì˜¤ë¥˜: í•„ìˆ˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
    print("í„°ë¯¸ë„ì— 'pip install openai speechrecognition edge-tts pygame pyaudio'ë¥¼ ì‹¤í–‰í•˜ì—¬ ì„¤ì¹˜í•´ì£¼ì„¸ìš”.")
    sys.exit(1)

OPENROUTER_API_KEY = "APIì—¬ê¸°ë‹¤ê°€ ì…ë ¥"

# ì‚¬ìš©í•˜ë ¤ëŠ” ë§ˆì´í¬ê°€ ê¸°ë³¸ ë§ˆì´í¬ê°€ ì•„ë‹ ê²½ìš°, ì•„ë˜ ëª©ë¡ì—ì„œ í™•ì¸ í›„ ìˆ«ìë¥¼ ë³€ê²½í•˜ì„¸ìš”.
# ì‚¬ìš© ê°€ëŠ¥í•œ ë§ˆì´í¬ ëª©ë¡ì€ ì½”ë“œë¥¼ ì²˜ìŒ ì‹¤í–‰í•  ë•Œ í„°ë¯¸ë„ì— ì¶œë ¥ë©ë‹ˆë‹¤.
# ì˜ˆ: MICROPHONE_INDEX = 1
MICROPHONE_INDEX = None

CONVERSATION_HISTORY = []

# --- ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ í´ë˜ìŠ¤ ---
class ConversationalAI:
    def __init__(self, api_key):
        """ì´ˆê¸°í™” ë©”ì„œë“œ"""
        self.api_key = api_key
        self.running = True
        self.is_speaking = threading.Event()

        # OpenAI í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” (OpenRouter ì‚¬ìš©)
        self.llm_client = OpenAI(
            api_key=self.api_key,
            base_url="https://openrouter.ai/api/v1",
            default_headers={
                "HTTP-Referer": "http://localhost",
                "X-Title": "Conversational AI",
            },
        )

        self.tts_queue = queue.Queue()
        self.tts_thread = threading.Thread(target=self._tts_worker, daemon=True)

        self.recognizer = sr.Recognizer()
        self.microphone = sr.Microphone(device_index=MICROPHONE_INDEX if MICROPHONE_INDEX is not None else None)

        # ì˜¤ë””ì˜¤ ì¬ìƒ ì´ˆê¸°í™”
        try:
            pygame.mixer.pre_init(44100, -16, 2, 512)
            pygame.mixer.init()
        except pygame.error as e:
            print(f"Pygame ë¯¹ì„œ ì´ˆê¸°í™” ì˜¤ë¥˜: {e}")
            print("ì˜¤ë””ì˜¤ ì¥ì¹˜ê°€ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€, ë“œë¼ì´ë²„ê°€ ì˜¬ë°”ë¥´ê²Œ ì„¤ì¹˜ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.")
            sys.exit(1)


    def _tts_worker(self):
        """TTS ìš”ì²­ì„ ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ"""
        asyncio.run(self._tts_worker_async())

    async def _tts_worker_async(self):
        """TTS ë¹„ë™ê¸° ì‘ì—…ì (íŒŒì¼ ì €ì¥ ë° ì¬ìƒ ë°©ì‹)"""
        while self.running:
            try:
                text_to_speak = self.tts_queue.get(timeout=1)
                if text_to_speak is None: break
                self.is_speaking.set()

                print(f"ğŸ¤– AI: {text_to_speak}")

                communicate = edge_tts.Communicate(text_to_speak, "ko-KR-SunHiNeural")
                with open("response.mp3", "wb") as file:
                    async for chunk in communicate.stream():
                        if chunk["type"] == "audio":
                            file.write(chunk["data"])

                pygame.mixer.music.load("response.mp3")
                pygame.mixer.music.play()
                while pygame.mixer.music.get_busy():
                    await asyncio.sleep(0.1)
                
                pygame.mixer.music.unload()
                await asyncio.sleep(0.1)

                try:
                    os.remove("response.mp3")
                except (PermissionError, OSError) as e:
                    print(f"ê²½ê³ : ì„ì‹œ ì˜¤ë””ì˜¤ íŒŒì¼('response.mp3')ì„ ì‚­ì œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: {e}")

                self.is_speaking.clear()
                self.tts_queue.task_done()

            except queue.Empty:
                continue
            except Exception as e:
                print(f"TTS ì‘ì—… ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
                self.is_speaking.clear()
                try:
                    pygame.mixer.music.unload()
                    if os.path.exists("response.mp3"):
                        os.remove("response.mp3")
                except Exception:
                    pass


    def speak(self, text):
        """ë§í•  í…ìŠ¤íŠ¸ë¥¼ TTS íì— ì¶”ê°€"""
        if self.running:
            self.tts_queue.put(text)

    def listen_and_process(self):
        """ì‚¬ìš©ìì˜ ìŒì„±ì„ ë“£ê³  ì „ì²´ ëŒ€í™” ê³¼ì •ì„ ì²˜ë¦¬"""
        try:
            mic_idx_str = str(MICROPHONE_INDEX) or "ê¸°ë³¸ ë§ˆì´í¬"
            print(f"ë§ˆì´í¬ '{mic_idx_str}'ë¥¼ ì—´ê³  ìˆìŠµë‹ˆë‹¤...")
            with self.microphone as source:
                print("ì£¼ë³€ ì†ŒìŒ ë¶„ì„ ì¤‘... (ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”)")
                self.recognizer.adjust_for_ambient_noise(source, duration=1)
                print(f"ì†ŒìŒ ë¶„ì„ ì™„ë£Œ. (ì—ë„ˆì§€ ì„ê³„ê°’: {self.recognizer.energy_threshold:.2f})")
        except Exception as e:
            mic_idx_str = str(MICROPHONE_INDEX) or "ê¸°ë³¸ ë§ˆì´í¬"
            print(f"ë§ˆì´í¬ '{mic_idx_str}'ë¥¼ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}")
            self.running = False
            return

        while self.running:
            if self.is_speaking.is_set():
                time.sleep(0.1)
                continue

            try:
                with self.microphone as source:
                    print("\nğŸ¤ ë“£ê³  ìˆìŠµë‹ˆë‹¤...")
                    audio = self.recognizer.listen(source, timeout=5, phrase_time_limit=10)

                print("...ìƒê° ì¤‘...")
                user_text = self.recognizer.recognize_google(audio, language="ko-KR")
                print(f"ğŸ‘¤ ì‚¬ìš©ì: {user_text}")

                CONVERSATION_HISTORY.append({"role": "user", "text": user_text})

                if any(keyword in user_text for keyword in ["ì¢…ë£Œ"]):
                    self.speak("ì•Œê² ìŠµë‹ˆë‹¤. ì¢‹ì€ í•˜ë£¨ ë³´ë‚´ì„¸ìš”.")
                    self.tts_queue.join()
                    self.stop()
                    break

                ai_response = self.ask_ai()
                CONVERSATION_HISTORY.append({"role": "assistant", "content": ai_response})
                self.speak(ai_response)
                
                self.tts_queue.join()

            except sr.WaitTimeoutError:
                continue
            except sr.UnknownValueError:
                print("ì£„ì†¡í•©ë‹ˆë‹¤, ì´í•´í•˜ì§€ ëª»í–ˆì–´ìš”. ë‹¤ì‹œ ë§ì”€í•´ì£¼ì‹œê² ì–´ìš”?")
                continue
            except sr.RequestError as e:
                print(f"ìŒì„± ì¸ì‹ ì„œë¹„ìŠ¤ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}")
                self.stop()

    def ask_ai(self):
        """LLM APIë¥¼ í˜¸ì¶œí•˜ì—¬ ë‹µë³€ì„ ìƒì„±"""
        if not CONVERSATION_HISTORY:
            return "ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?"

        system_prompt = {
            "role": "system",
            "content": "í•µì‹¬ë§Œ ê°„ê²°í•˜ê²Œ 3~5ë¬¸ì¥ ì´ë‚´ë¡œ ë‹µë³€."
        }
        messages = [system_prompt] + CONVERSATION_HISTORY[-10:]

        try:
            response = self.llm_client.chat.completions.create(
                model="deepseek/deepseek-chat-v3.1:free:nitro",
                messages=messages,
                stream=False
            )
            raw_content = response.choices[0].message.content
            cleaned_content = re.sub(r'<think>.*?</think>', '', raw_content, flags=re.DOTALL)
            cleaned_content = cleaned_content.strip()
            return cleaned_content
        except APIStatusError as e:
            print(f"LLM API ìƒíƒœ ì˜¤ë¥˜ ë°œìƒ: {e.status_code} - {e.response}")
            if e.status_code == 401:
                return "API í‚¤ ì¸ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì½”ë“œ ìƒë‹¨ì˜ API í‚¤ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."
            elif e.status_code == 429:
                return "API í•˜ë£¨ ì‚¬ìš©ëŸ‰ì„ ì´ˆê³¼í–ˆê±°ë‚˜ ìš”ì²­ì´ ë„ˆë¬´ ë§ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
            else:
                return f"API ì„œë²„ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. (ì½”ë“œ: {e.status_code})"
        except Exception as e:
            print(f"LLM API í˜¸ì¶œ ì¤‘ ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜ ë°œìƒ: {e}")
            return "ì£„ì†¡í•©ë‹ˆë‹¤. ë‹µë³€ì„ ìƒì„±í•˜ëŠ” ì¤‘ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."

    def start(self):
        """ëŒ€í™”í˜• AI ì‹œì‘"""
        self.tts_thread.start()
        self.speak("ì•ˆë…•í•˜ì„¸ìš”, ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?")
        self.listen_and_process()

    def stop(self):
        """ì• í”Œë¦¬ì¼€ì´ì…˜ ì¢…ë£Œ"""
        if self.running:
            self.running = False
            self.tts_queue.put(None)
            print("\ní”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤...")

def keyboard_listener(ai_instance):
    """'q' ì…ë ¥ ì‹œ ì¢…ë£Œí•˜ëŠ” ë¦¬ìŠ¤ë„ˆ"""
    while ai_instance.running:
        try:
            if sys.stdin.isatty():
                inp = input()
                if inp.lower() == 'q':
                    print("'q' ì…ë ¥ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")
                    ai_instance.stop()
                    break
        except (EOFError, KeyboardInterrupt):
            break
        except Exception:
            time.sleep(1)

def check_microphones():
    """ì‹œìŠ¤í…œì— ì—°ê²°ëœ ë§ˆì´í¬ ëª©ë¡ì„ ì¶œë ¥í•˜ëŠ” í•¨ìˆ˜"""
    print("--- ì‚¬ìš© ê°€ëŠ¥í•œ ë§ˆì´í¬ ëª©ë¡ ---")
    try:
        mic_list = sr.Microphone.list_microphone_names()
        if not mic_list:
            print("ì‚¬ìš© ê°€ëŠ¥í•œ ë§ˆì´í¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return False
        
        for index, name in enumerate(mic_list):
            print(f"  ë§ˆì´í¬ {index}: {name}")
        print("---------------------------------")
        print("ê¸°ë³¸ ë§ˆì´í¬ê°€ ì•„ë‹Œ ë‹¤ë¥¸ ë§ˆì´í¬ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´, ì½”ë“œ ìƒë‹¨ì˜ 'MICROPHONE_INDEX' ê°’ì„ í•´ë‹¹ ë§ˆì´í¬ì˜ ë²ˆí˜¸ë¡œ ë³€ê²½í•˜ì„¸ìš”.")
        return True
    except Exception as e:
        print(f"ë§ˆì´í¬ ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        return False

def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    if not check_microphones():
        return

    if not OPENROUTER_API_KEY or OPENROUTER_API_KEY == "YOUR_API_KEY_HERE":
        print("\n[ì˜¤ë¥˜] API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        print("ì½”ë“œ ìƒë‹¨ì˜ 'OPENROUTER_API_KEY' ë³€ìˆ˜ì— ìœ íš¨í•œ í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”.")
        return

    ai = ConversationalAI(OPENROUTER_API_KEY)

    input_thread = threading.Thread(target=keyboard_listener, args=(ai,), daemon=True)
    input_thread.start()
    print("\ní”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•˜ë ¤ë©´ 'q'ë¥¼ ì…ë ¥í•˜ê³  Enter í‚¤ë¥¼ ëˆ„ë¥´ì„¸ìš”.")

    try:
        ai.start()
    except KeyboardInterrupt:
        ai.stop()
    finally:
        pygame.mixer.quit()
        if os.path.exists("response.mp3"):
            try:
                os.remove("response.mp3")
            except (PermissionError, OSError) as e:
                print(f"ê²½ê³ : ì¢…ë£Œ ì‹œ ì„ì‹œ íŒŒì¼ì„ ì‚­ì œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: {e}")


if __name__ == "__main__":
    main()
